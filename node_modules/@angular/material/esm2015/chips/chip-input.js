/**
 * @fileoverview added by tsickle
 * Generated from: src/material/chips/chip-input.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Directive, ElementRef, EventEmitter, Inject, Input, Output } from '@angular/core';
import { hasModifierKey, TAB } from '@angular/cdk/keycodes';
import { MAT_CHIPS_DEFAULT_OPTIONS } from './chip-default-options';
import { MatChipList } from './chip-list';
/**
 * Represents an input event on a `matChipInput`.
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function MatChipInputEvent() { }
if (false) {
    /**
     * The native `<input>` element that the event is being fired for.
     * @type {?}
     */
    MatChipInputEvent.prototype.input;
    /**
     * The value of the input.
     * @type {?}
     */
    MatChipInputEvent.prototype.value;
}
// Increasing integer for generating unique ids.
/** @type {?} */
let nextUniqueId = 0;
/**
 * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.
 * May be placed inside or outside of an `<mat-chip-list>`.
 */
export class MatChipInput {
    /**
     * @param {?} _elementRef
     * @param {?} _defaultOptions
     */
    constructor(_elementRef, _defaultOptions) {
        this._elementRef = _elementRef;
        this._defaultOptions = _defaultOptions;
        /**
         * Whether the control is focused.
         */
        this.focused = false;
        this._addOnBlur = false;
        /**
         * The list of key codes that will trigger a chipEnd event.
         *
         * Defaults to `[ENTER]`.
         */
        this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;
        /**
         * Emitted when a chip is to be added.
         */
        this.chipEnd = new EventEmitter();
        /**
         * The input's placeholder text.
         */
        this.placeholder = '';
        /**
         * Unique id for the input.
         */
        this.id = `mat-chip-list-input-${nextUniqueId++}`;
        this._disabled = false;
        this._inputElement = (/** @type {?} */ (this._elementRef.nativeElement));
    }
    /**
     * Register input for chip list
     * @param {?} value
     * @return {?}
     */
    set chipList(value) {
        if (value) {
            this._chipList = value;
            this._chipList.registerInput(this);
        }
    }
    /**
     * Whether or not the chipEnd event will be emitted when the input is blurred.
     * @return {?}
     */
    get addOnBlur() { return this._addOnBlur; }
    /**
     * @param {?} value
     * @return {?}
     */
    set addOnBlur(value) { this._addOnBlur = coerceBooleanProperty(value); }
    /**
     * Whether the input is disabled.
     * @return {?}
     */
    get disabled() { return this._disabled || (this._chipList && this._chipList.disabled); }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) { this._disabled = coerceBooleanProperty(value); }
    /**
     * Whether the input is empty.
     * @return {?}
     */
    get empty() { return !this._inputElement.value; }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this._chipList.stateChanges.next();
    }
    /**
     * Utility method to make host definition/tests more clear.
     * @param {?=} event
     * @return {?}
     */
    _keydown(event) {
        // Allow the user's focus to escape when they're tabbing forward. Note that we don't
        // want to do this when going backwards, because focus should go back to the first chip.
        if (event && event.keyCode === TAB && !hasModifierKey(event, 'shiftKey')) {
            this._chipList._allowFocusEscape();
        }
        this._emitChipEnd(event);
    }
    /**
     * Checks to see if the blur should emit the (chipEnd) event.
     * @return {?}
     */
    _blur() {
        if (this.addOnBlur) {
            this._emitChipEnd();
        }
        this.focused = false;
        // Blur the chip list if it is not focused
        if (!this._chipList.focused) {
            this._chipList._blur();
        }
        this._chipList.stateChanges.next();
    }
    /**
     * @return {?}
     */
    _focus() {
        this.focused = true;
        this._chipList.stateChanges.next();
    }
    /**
     * Checks to see if the (chipEnd) event needs to be emitted.
     * @param {?=} event
     * @return {?}
     */
    _emitChipEnd(event) {
        if (!this._inputElement.value && !!event) {
            this._chipList._keydown(event);
        }
        if (!event || this._isSeparatorKey(event)) {
            this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });
            if (event) {
                event.preventDefault();
            }
        }
    }
    /**
     * @return {?}
     */
    _onInput() {
        // Let chip list know whenever the value changes.
        this._chipList.stateChanges.next();
    }
    /**
     * Focuses the input.
     * @param {?=} options
     * @return {?}
     */
    focus(options) {
        this._inputElement.focus(options);
    }
    /**
     * Checks whether a keycode is one of the configured separators.
     * @private
     * @param {?} event
     * @return {?}
     */
    _isSeparatorKey(event) {
        if (hasModifierKey(event)) {
            return false;
        }
        /** @type {?} */
        const separators = this.separatorKeyCodes;
        /** @type {?} */
        const keyCode = event.keyCode;
        return Array.isArray(separators) ? separators.indexOf(keyCode) > -1 : separators.has(keyCode);
    }
}
MatChipInput.ɵfac = function MatChipInput_Factory(t) { return new (t || MatChipInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MAT_CHIPS_DEFAULT_OPTIONS)); };
MatChipInput.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatChipInput, selectors: [["input", "matChipInputFor", ""]], hostAttrs: [1, "mat-chip-input", "mat-input-element"], hostVars: 5, hostBindings: function MatChipInput_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function MatChipInput_keydown_HostBindingHandler($event) { return ctx._keydown($event); })("blur", function MatChipInput_blur_HostBindingHandler($event) { return ctx._blur(); })("focus", function MatChipInput_focus_HostBindingHandler($event) { return ctx._focus(); })("input", function MatChipInput_input_HostBindingHandler($event) { return ctx._onInput(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.id);
        ɵngcc0.ɵɵattribute("disabled", ctx.disabled || null)("placeholder", ctx.placeholder || null)("aria-invalid", ctx._chipList && ctx._chipList.ngControl ? ctx._chipList.ngControl.invalid : null)("aria-required", ctx._chipList && ctx._chipList.required || null);
    } }, inputs: { separatorKeyCodes: ["matChipInputSeparatorKeyCodes", "separatorKeyCodes"], placeholder: "placeholder", id: "id", chipList: ["matChipInputFor", "chipList"], addOnBlur: ["matChipInputAddOnBlur", "addOnBlur"], disabled: "disabled" }, outputs: { chipEnd: "matChipInputTokenEnd" }, exportAs: ["matChipInput", "matChipInputFor"], features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/** @nocollapse */
MatChipInput.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_CHIPS_DEFAULT_OPTIONS,] }] }
];
MatChipInput.propDecorators = {
    chipList: [{ type: Input, args: ['matChipInputFor',] }],
    addOnBlur: [{ type: Input, args: ['matChipInputAddOnBlur',] }],
    separatorKeyCodes: [{ type: Input, args: ['matChipInputSeparatorKeyCodes',] }],
    chipEnd: [{ type: Output, args: ['matChipInputTokenEnd',] }],
    placeholder: [{ type: Input }],
    id: [{ type: Input }],
    disabled: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatChipInput, [{
        type: Directive,
        args: [{
                selector: 'input[matChipInputFor]',
                exportAs: 'matChipInput, matChipInputFor',
                host: {
                    'class': 'mat-chip-input mat-input-element',
                    '(keydown)': '_keydown($event)',
                    '(blur)': '_blur()',
                    '(focus)': '_focus()',
                    '(input)': '_onInput()',
                    '[id]': 'id',
                    '[attr.disabled]': 'disabled || null',
                    '[attr.placeholder]': 'placeholder || null',
                    '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',
                    '[attr.aria-required]': '_chipList && _chipList.required || null'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_CHIPS_DEFAULT_OPTIONS]
            }] }]; }, { separatorKeyCodes: [{
            type: Input,
            args: ['matChipInputSeparatorKeyCodes']
        }], chipEnd: [{
            type: Output,
            args: ['matChipInputTokenEnd']
        }], placeholder: [{
            type: Input
        }], id: [{
            type: Input
        }], chipList: [{
            type: Input,
            args: ['matChipInputFor']
        }], addOnBlur: [{
            type: Input,
            args: ['matChipInputAddOnBlur']
        }], disabled: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    MatChipInput.ngAcceptInputType_addOnBlur;
    /** @type {?} */
    MatChipInput.ngAcceptInputType_disabled;
    /**
     * Whether the control is focused.
     * @type {?}
     */
    MatChipInput.prototype.focused;
    /** @type {?} */
    MatChipInput.prototype._chipList;
    /** @type {?} */
    MatChipInput.prototype._addOnBlur;
    /**
     * The list of key codes that will trigger a chipEnd event.
     *
     * Defaults to `[ENTER]`.
     * @type {?}
     */
    MatChipInput.prototype.separatorKeyCodes;
    /**
     * Emitted when a chip is to be added.
     * @type {?}
     */
    MatChipInput.prototype.chipEnd;
    /**
     * The input's placeholder text.
     * @type {?}
     */
    MatChipInput.prototype.placeholder;
    /**
     * Unique id for the input.
     * @type {?}
     */
    MatChipInput.prototype.id;
    /**
     * @type {?}
     * @private
     */
    MatChipInput.prototype._disabled;
    /**
     * The native input element to which this directive is attached.
     * @type {?}
     * @protected
     */
    MatChipInput.prototype._inputElement;
    /**
     * @type {?}
     * @protected
     */
    MatChipInput.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MatChipInput.prototype._defaultOptions;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L2ZpbmFsMy9jdXJzb3Mvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL21hdGVyaWFsL2VzbTIwMTUvY2hpcHMvY2hpcC1pbnB1dC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrTEMsbVlBa0JDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBY0EiLCJmaWxlIjoiY2hpcC1pbnB1dC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBHZW5lcmF0ZWQgZnJvbTogc3JjL21hdGVyaWFsL2NoaXBzL2NoaXAtaW5wdXQudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaGFzTW9kaWZpZXJLZXksIFRBQiB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBNQVRfQ0hJUFNfREVGQVVMVF9PUFRJT05TIH0gZnJvbSAnLi9jaGlwLWRlZmF1bHQtb3B0aW9ucyc7XG5pbXBvcnQgeyBNYXRDaGlwTGlzdCB9IGZyb20gJy4vY2hpcC1saXN0Jztcbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnB1dCBldmVudCBvbiBhIGBtYXRDaGlwSW5wdXRgLlxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gTWF0Q2hpcElucHV0RXZlbnQoKSB7IH1cbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYXRpdmUgYDxpbnB1dD5gIGVsZW1lbnQgdGhhdCB0aGUgZXZlbnQgaXMgYmVpbmcgZmlyZWQgZm9yLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE1hdENoaXBJbnB1dEV2ZW50LnByb3RvdHlwZS5pbnB1dDtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIGlucHV0LlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE1hdENoaXBJbnB1dEV2ZW50LnByb3RvdHlwZS52YWx1ZTtcbn1cbi8vIEluY3JlYXNpbmcgaW50ZWdlciBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgaWRzLlxuLyoqIEB0eXBlIHs/fSAqL1xubGV0IG5leHRVbmlxdWVJZCA9IDA7XG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IGFkZHMgY2hpcC1zcGVjaWZpYyBiZWhhdmlvcnMgdG8gYW4gaW5wdXQgZWxlbWVudCBpbnNpZGUgYDxtYXQtZm9ybS1maWVsZD5gLlxuICogTWF5IGJlIHBsYWNlZCBpbnNpZGUgb3Igb3V0c2lkZSBvZiBhbiBgPG1hdC1jaGlwLWxpc3Q+YC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hdENoaXBJbnB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gX2RlZmF1bHRPcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnRSZWYsIF9kZWZhdWx0T3B0aW9ucykge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gX2RlZmF1bHRPcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY29udHJvbCBpcyBmb2N1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FkZE9uQmx1ciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3Qgb2Yga2V5IGNvZGVzIHRoYXQgd2lsbCB0cmlnZ2VyIGEgY2hpcEVuZCBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogRGVmYXVsdHMgdG8gYFtFTlRFUl1gLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXBhcmF0b3JLZXlDb2RlcyA9IHRoaXMuX2RlZmF1bHRPcHRpb25zLnNlcGFyYXRvcktleUNvZGVzO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHRlZCB3aGVuIGEgY2hpcCBpcyB0byBiZSBhZGRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpcEVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnB1dCdzIHBsYWNlaG9sZGVyIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmlxdWUgaWQgZm9yIHRoZSBpbnB1dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBgbWF0LWNoaXAtbGlzdC1pbnB1dC0ke25leHRVbmlxdWVJZCsrfWA7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudCA9ICgvKiogQHR5cGUgez99ICovICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgaW5wdXQgZm9yIGNoaXAgbGlzdFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCBjaGlwTGlzdCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoaXBMaXN0ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jaGlwTGlzdC5yZWdpc3RlcklucHV0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjaGlwRW5kIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aGVuIHRoZSBpbnB1dCBpcyBibHVycmVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IGFkZE9uQmx1cigpIHsgcmV0dXJuIHRoaXMuX2FkZE9uQmx1cjsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCBhZGRPbkJsdXIodmFsdWUpIHsgdGhpcy5fYWRkT25CbHVyID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQgfHwgKHRoaXMuX2NoaXBMaXN0ICYmIHRoaXMuX2NoaXBMaXN0LmRpc2FibGVkKTsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBpbnB1dCBpcyBlbXB0eS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuICF0aGlzLl9pbnB1dEVsZW1lbnQudmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLl9jaGlwTGlzdC5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCB0byBtYWtlIGhvc3QgZGVmaW5pdGlvbi90ZXN0cyBtb3JlIGNsZWFyLlxuICAgICAqIEBwYXJhbSB7Pz19IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfa2V5ZG93bihldmVudCkge1xuICAgICAgICAvLyBBbGxvdyB0aGUgdXNlcidzIGZvY3VzIHRvIGVzY2FwZSB3aGVuIHRoZXkncmUgdGFiYmluZyBmb3J3YXJkLiBOb3RlIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gd2FudCB0byBkbyB0aGlzIHdoZW4gZ29pbmcgYmFja3dhcmRzLCBiZWNhdXNlIGZvY3VzIHNob3VsZCBnbyBiYWNrIHRvIHRoZSBmaXJzdCBjaGlwLlxuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQua2V5Q29kZSA9PT0gVEFCICYmICFoYXNNb2RpZmllcktleShldmVudCwgJ3NoaWZ0S2V5JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoaXBMaXN0Ll9hbGxvd0ZvY3VzRXNjYXBlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdENoaXBFbmQoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBibHVyIHNob3VsZCBlbWl0IHRoZSAoY2hpcEVuZCkgZXZlbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfYmx1cigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWRkT25CbHVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0Q2hpcEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvLyBCbHVyIHRoZSBjaGlwIGxpc3QgaWYgaXQgaXMgbm90IGZvY3VzZWRcbiAgICAgICAgaWYgKCF0aGlzLl9jaGlwTGlzdC5mb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGlwTGlzdC5fYmx1cigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoaXBMaXN0LnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2ZvY3VzKCkge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jaGlwTGlzdC5zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSAoY2hpcEVuZCkgZXZlbnQgbmVlZHMgdG8gYmUgZW1pdHRlZC5cbiAgICAgKiBAcGFyYW0gez89fSBldmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2VtaXRDaGlwRW5kKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faW5wdXRFbGVtZW50LnZhbHVlICYmICEhZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoaXBMaXN0Ll9rZXlkb3duKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2ZW50IHx8IHRoaXMuX2lzU2VwYXJhdG9yS2V5KGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jaGlwRW5kLmVtaXQoeyBpbnB1dDogdGhpcy5faW5wdXRFbGVtZW50LCB2YWx1ZTogdGhpcy5faW5wdXRFbGVtZW50LnZhbHVlIH0pO1xuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9vbklucHV0KCkge1xuICAgICAgICAvLyBMZXQgY2hpcCBsaXN0IGtub3cgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgIHRoaXMuX2NoaXBMaXN0LnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZvY3VzKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50LmZvY3VzKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIGtleWNvZGUgaXMgb25lIG9mIHRoZSBjb25maWd1cmVkIHNlcGFyYXRvcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfaXNTZXBhcmF0b3JLZXkoZXZlbnQpIHtcbiAgICAgICAgaWYgKGhhc01vZGlmaWVyS2V5KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgc2VwYXJhdG9ycyA9IHRoaXMuc2VwYXJhdG9yS2V5Q29kZXM7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNlcGFyYXRvcnMpID8gc2VwYXJhdG9ycy5pbmRleE9mKGtleUNvZGUpID4gLTEgOiBzZXBhcmF0b3JzLmhhcyhrZXlDb2RlKTtcbiAgICB9XG59XG5NYXRDaGlwSW5wdXQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W21hdENoaXBJbnB1dEZvcl0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbWF0Q2hpcElucHV0LCBtYXRDaGlwSW5wdXRGb3InLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1jaGlwLWlucHV0IG1hdC1pbnB1dC1lbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdfa2V5ZG93bigkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfYmx1cigpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhmb2N1cyknOiAnX2ZvY3VzKCknLFxuICAgICAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdfb25JbnB1dCgpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tpZF0nOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuZGlzYWJsZWRdJzogJ2Rpc2FibGVkIHx8IG51bGwnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIucGxhY2Vob2xkZXJdJzogJ3BsYWNlaG9sZGVyIHx8IG51bGwnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1pbnZhbGlkXSc6ICdfY2hpcExpc3QgJiYgX2NoaXBMaXN0Lm5nQ29udHJvbCA/IF9jaGlwTGlzdC5uZ0NvbnRyb2wuaW52YWxpZCA6IG51bGwnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1yZXF1aXJlZF0nOiAnX2NoaXBMaXN0ICYmIF9jaGlwTGlzdC5yZXF1aXJlZCB8fCBudWxsJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTWF0Q2hpcElucHV0LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNQVRfQ0hJUFNfREVGQVVMVF9PUFRJT05TLF0gfV0gfVxuXTtcbk1hdENoaXBJbnB1dC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjaGlwTGlzdDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0Q2hpcElucHV0Rm9yJyxdIH1dLFxuICAgIGFkZE9uQmx1cjogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0Q2hpcElucHV0QWRkT25CbHVyJyxdIH1dLFxuICAgIHNlcGFyYXRvcktleUNvZGVzOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXRDaGlwSW5wdXRTZXBhcmF0b3JLZXlDb2RlcycsXSB9XSxcbiAgICBjaGlwRW5kOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWF0Q2hpcElucHV0VG9rZW5FbmQnLF0gfV0sXG4gICAgcGxhY2Vob2xkZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTWF0Q2hpcElucHV0Lm5nQWNjZXB0SW5wdXRUeXBlX2FkZE9uQmx1cjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTWF0Q2hpcElucHV0Lm5nQWNjZXB0SW5wdXRUeXBlX2Rpc2FibGVkO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNvbnRyb2wgaXMgZm9jdXNlZC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRDaGlwSW5wdXQucHJvdG90eXBlLmZvY3VzZWQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdENoaXBJbnB1dC5wcm90b3R5cGUuX2NoaXBMaXN0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBNYXRDaGlwSW5wdXQucHJvdG90eXBlLl9hZGRPbkJsdXI7XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2Yga2V5IGNvZGVzIHRoYXQgd2lsbCB0cmlnZ2VyIGEgY2hpcEVuZCBldmVudC5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIGBbRU5URVJdYC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRDaGlwSW5wdXQucHJvdG90eXBlLnNlcGFyYXRvcktleUNvZGVzO1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIGNoaXAgaXMgdG8gYmUgYWRkZWQuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0Q2hpcElucHV0LnByb3RvdHlwZS5jaGlwRW5kO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCdzIHBsYWNlaG9sZGVyIHRleHQuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0Q2hpcElucHV0LnByb3RvdHlwZS5wbGFjZWhvbGRlcjtcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgaWQgZm9yIHRoZSBpbnB1dC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRDaGlwSW5wdXQucHJvdG90eXBlLmlkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWF0Q2hpcElucHV0LnByb3RvdHlwZS5fZGlzYWJsZWQ7XG4gICAgLyoqXG4gICAgICogVGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IHRvIHdoaWNoIHRoaXMgZGlyZWN0aXZlIGlzIGF0dGFjaGVkLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBNYXRDaGlwSW5wdXQucHJvdG90eXBlLl9pbnB1dEVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIE1hdENoaXBJbnB1dC5wcm90b3R5cGUuX2VsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNYXRDaGlwSW5wdXQucHJvdG90eXBlLl9kZWZhdWx0T3B0aW9ucztcbn1cbiJdfQ==