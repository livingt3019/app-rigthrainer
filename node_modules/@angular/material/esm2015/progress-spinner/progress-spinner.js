/**
 * @fileoverview added by tsickle
 * Generated from: src/material/progress-spinner/progress-spinner.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { Platform } from '@angular/cdk/platform';
import { DOCUMENT } from '@angular/common';
import { ChangeDetectionStrategy, Component, ElementRef, Inject, InjectionToken, Input, Optional, ViewEncapsulation, } from '@angular/core';
import { mixinColor } from '@angular/material/core';
import { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';
/**
 * Base reference size of the spinner.
 * \@docs-private
 * @type {?}
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/platform';
import * as ɵngcc2 from '@angular/common';

function MatProgressSpinner__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 3);
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("animation-name", "mat-progress-spinner-stroke-rotate-" + ctx_r12.diameter)("stroke-dashoffset", ctx_r12._strokeDashOffset, "px")("stroke-dasharray", ctx_r12._strokeCircumference, "px")("stroke-width", ctx_r12._circleStrokeWidth, "%");
    ɵngcc0.ɵɵattribute("r", ctx_r12._circleRadius);
} }
function MatProgressSpinner__svg_circle_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 3);
} if (rf & 2) {
    const ctx_r13 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("stroke-dashoffset", ctx_r13._strokeDashOffset, "px")("stroke-dasharray", ctx_r13._strokeCircumference, "px")("stroke-width", ctx_r13._circleStrokeWidth, "%");
    ɵngcc0.ɵɵattribute("r", ctx_r13._circleRadius);
} }
function MatSpinner__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 3);
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("animation-name", "mat-progress-spinner-stroke-rotate-" + ctx_r14.diameter)("stroke-dashoffset", ctx_r14._strokeDashOffset, "px")("stroke-dasharray", ctx_r14._strokeCircumference, "px")("stroke-width", ctx_r14._circleStrokeWidth, "%");
    ɵngcc0.ɵɵattribute("r", ctx_r14._circleRadius);
} }
function MatSpinner__svg_circle_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 3);
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("stroke-dashoffset", ctx_r15._strokeDashOffset, "px")("stroke-dasharray", ctx_r15._strokeCircumference, "px")("stroke-width", ctx_r15._circleStrokeWidth, "%");
    ɵngcc0.ɵɵattribute("r", ctx_r15._circleRadius);
} }
const BASE_SIZE = 100;
/**
 * Base reference stroke width of the spinner.
 * \@docs-private
 * @type {?}
 */
const BASE_STROKE_WIDTH = 10;
// Boilerplate for applying mixins to MatProgressSpinner.
/**
 * \@docs-private
 */
class MatProgressSpinnerBase {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}
if (false) {
    /** @type {?} */
    MatProgressSpinnerBase.prototype._elementRef;
}
/** @type {?} */
const _MatProgressSpinnerMixinBase = mixinColor(MatProgressSpinnerBase, 'primary');
/**
 * Default `mat-progress-spinner` options that can be overridden.
 * @record
 */
export function MatProgressSpinnerDefaultOptions() { }
if (false) {
    /**
     * Diameter of the spinner.
     * @type {?|undefined}
     */
    MatProgressSpinnerDefaultOptions.prototype.diameter;
    /**
     * Width of the spinner's stroke.
     * @type {?|undefined}
     */
    MatProgressSpinnerDefaultOptions.prototype.strokeWidth;
    /**
     * Whether the animations should be force to be enabled, ignoring if the current environment is
     * using NoopAnimationsModule.
     * @type {?|undefined}
     */
    MatProgressSpinnerDefaultOptions.prototype._forceAnimations;
}
/**
 * Injection token to be used to override the default options for `mat-progress-spinner`.
 * @type {?}
 */
export const MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS = new InjectionToken('mat-progress-spinner-default-options', {
    providedIn: 'root',
    factory: MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY,
});
/**
 * \@docs-private
 * @return {?}
 */
export function MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY() {
    return { diameter: BASE_SIZE };
}
// .0001 percentage difference is necessary in order to avoid unwanted animation frames
// for example because the animation duration is 4 seconds, .1% accounts to 4ms
// which are enough to see the flicker described in
// https://github.com/angular/components/issues/8984
/** @type {?} */
const INDETERMINATE_ANIMATION_TEMPLATE = `
 @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {
    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }
    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }
    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }
    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }

    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }
    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }
    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }
    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }

    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }
    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }
    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }
    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }

    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }
    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }
    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }
    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }
  }
`;
/**
 * `<mat-progress-spinner>` component.
 */
export class MatProgressSpinner extends _MatProgressSpinnerMixinBase {
    /**
     * @param {?} _elementRef
     * @param {?} platform
     * @param {?} _document
     * @param {?} animationMode
     * @param {?=} defaults
     */
    constructor(_elementRef, platform, _document, animationMode, defaults) {
        super(_elementRef);
        this._elementRef = _elementRef;
        this._document = _document;
        this._diameter = BASE_SIZE;
        this._value = 0;
        this._fallbackAnimation = false;
        /**
         * Mode of the progress circle
         */
        this.mode = 'determinate';
        /** @type {?} */
        const trackedDiameters = MatProgressSpinner._diameters;
        // The base size is already inserted via the component's structural styles. We still
        // need to track it so we don't end up adding the same styles again.
        if (!trackedDiameters.has(_document.head)) {
            trackedDiameters.set(_document.head, new Set([BASE_SIZE]));
        }
        this._fallbackAnimation = platform.EDGE || platform.TRIDENT;
        this._noopAnimations = animationMode === 'NoopAnimations' &&
            (!!defaults && !defaults._forceAnimations);
        if (defaults) {
            if (defaults.diameter) {
                this.diameter = defaults.diameter;
            }
            if (defaults.strokeWidth) {
                this.strokeWidth = defaults.strokeWidth;
            }
        }
    }
    /**
     * The diameter of the progress spinner (will set width and height of svg).
     * @return {?}
     */
    get diameter() { return this._diameter; }
    /**
     * @param {?} size
     * @return {?}
     */
    set diameter(size) {
        this._diameter = coerceNumberProperty(size);
        // If this is set before `ngOnInit`, the style root may not have been resolved yet.
        if (!this._fallbackAnimation && this._styleRoot) {
            this._attachStyleNode();
        }
    }
    /**
     * Stroke width of the progress spinner.
     * @return {?}
     */
    get strokeWidth() {
        return this._strokeWidth || this.diameter / 10;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set strokeWidth(value) {
        this._strokeWidth = coerceNumberProperty(value);
    }
    /**
     * Value of the progress circle.
     * @return {?}
     */
    get value() {
        return this.mode === 'determinate' ? this._value : 0;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set value(newValue) {
        this._value = Math.max(0, Math.min(100, coerceNumberProperty(newValue)));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const element = this._elementRef.nativeElement;
        // Note that we need to look up the root node in ngOnInit, rather than the constructor, because
        // Angular seems to create the element outside the shadow root and then moves it inside, if the
        // node is inside an `ngIf` and a ShadowDom-encapsulated component.
        this._styleRoot = _getShadowRoot(element, this._document) || this._document.head;
        this._attachStyleNode();
        // On IE and Edge, we can't animate the `stroke-dashoffset`
        // reliably so we fall back to a non-spec animation.
        /** @type {?} */
        const animationClass = `mat-progress-spinner-indeterminate${this._fallbackAnimation ? '-fallback' : ''}-animation`;
        element.classList.add(animationClass);
    }
    /**
     * The radius of the spinner, adjusted for stroke width.
     * @return {?}
     */
    get _circleRadius() {
        return (this.diameter - BASE_STROKE_WIDTH) / 2;
    }
    /**
     * The view box of the spinner's svg element.
     * @return {?}
     */
    get _viewBox() {
        /** @type {?} */
        const viewBox = this._circleRadius * 2 + this.strokeWidth;
        return `0 0 ${viewBox} ${viewBox}`;
    }
    /**
     * The stroke circumference of the svg circle.
     * @return {?}
     */
    get _strokeCircumference() {
        return 2 * Math.PI * this._circleRadius;
    }
    /**
     * The dash offset of the svg circle.
     * @return {?}
     */
    get _strokeDashOffset() {
        if (this.mode === 'determinate') {
            return this._strokeCircumference * (100 - this._value) / 100;
        }
        // In fallback mode set the circle to 80% and rotate it with CSS.
        if (this._fallbackAnimation && this.mode === 'indeterminate') {
            return this._strokeCircumference * 0.2;
        }
        return null;
    }
    /**
     * Stroke width of the circle in percent.
     * @return {?}
     */
    get _circleStrokeWidth() {
        return this.strokeWidth / this.diameter * 100;
    }
    /**
     * Dynamically generates a style tag containing the correct animation for this diameter.
     * @private
     * @return {?}
     */
    _attachStyleNode() {
        /** @type {?} */
        const styleRoot = this._styleRoot;
        /** @type {?} */
        const currentDiameter = this._diameter;
        /** @type {?} */
        const diameters = MatProgressSpinner._diameters;
        /** @type {?} */
        let diametersForElement = diameters.get(styleRoot);
        if (!diametersForElement || !diametersForElement.has(currentDiameter)) {
            /** @type {?} */
            const styleTag = this._document.createElement('style');
            styleTag.setAttribute('mat-spinner-animation', currentDiameter + '');
            styleTag.textContent = this._getAnimationText();
            styleRoot.appendChild(styleTag);
            if (!diametersForElement) {
                diametersForElement = new Set();
                diameters.set(styleRoot, diametersForElement);
            }
            diametersForElement.add(currentDiameter);
        }
    }
    /**
     * Generates animation styles adjusted for the spinner's diameter.
     * @private
     * @return {?}
     */
    _getAnimationText() {
        return INDETERMINATE_ANIMATION_TEMPLATE
            // Animation should begin at 5% and end at 80%
            .replace(/START_VALUE/g, `${0.95 * this._strokeCircumference}`)
            .replace(/END_VALUE/g, `${0.2 * this._strokeCircumference}`)
            .replace(/DIAMETER/g, `${this.diameter}`);
    }
}
MatProgressSpinner.ɵfac = function MatProgressSpinner_Factory(t) { return new (t || MatProgressSpinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS)); };
MatProgressSpinner.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatProgressSpinner, selectors: [["mat-progress-spinner"]], hostAttrs: ["role", "progressbar", 1, "mat-progress-spinner"], hostVars: 10, hostBindings: function MatProgressSpinner_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.mode === "determinate" ? 0 : null)("aria-valuemax", ctx.mode === "determinate" ? 100 : null)("aria-valuenow", ctx.mode === "determinate" ? ctx.value : null)("mode", ctx.mode);
        ɵngcc0.ɵɵstyleProp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        ɵngcc0.ɵɵclassProp("_mat-animation-noopable", ctx._noopAnimations);
    } }, inputs: { color: "color", mode: "mode", diameter: "diameter", strokeWidth: "strokeWidth", value: "value" }, exportAs: ["matProgressSpinner"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function MatProgressSpinner_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0);
        ɵngcc0.ɵɵtemplate(1, MatProgressSpinner__svg_circle_1_Template, 1, 9, "circle", 1);
        ɵngcc0.ɵɵtemplate(2, MatProgressSpinner__svg_circle_2_Template, 1, 7, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.mode === "indeterminate");
        ɵngcc0.ɵɵattribute("viewBox", ctx._viewBox);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", false);
    } }, directives: [ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase], styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"], encapsulation: 2, changeDetection: 0 });
/**
 * Tracks diameters of existing instances to de-dupe generated styles (default d = 100).
 * We need to keep track of which elements the diameters were attached to, because for
 * elements in the Shadow DOM the style tags are attached to the shadow root, rather
 * than the document head.
 */
MatProgressSpinner._diameters = new WeakMap();
/** @nocollapse */
MatProgressSpinner.ctorParameters = () => [
    { type: ElementRef },
    { type: Platform },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
];
MatProgressSpinner.propDecorators = {
    diameter: [{ type: Input }],
    strokeWidth: [{ type: Input }],
    mode: [{ type: Input }],
    value: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatProgressSpinner, [{
        type: Component,
        args: [{
                selector: 'mat-progress-spinner',
                exportAs: 'matProgressSpinner',
                host: {
                    'role': 'progressbar',
                    'class': 'mat-progress-spinner',
                    '[class._mat-animation-noopable]': `_noopAnimations`,
                    '[style.width.px]': 'diameter',
                    '[style.height.px]': 'diameter',
                    '[attr.aria-valuemin]': 'mode === "determinate" ? 0 : null',
                    '[attr.aria-valuemax]': 'mode === "determinate" ? 100 : null',
                    '[attr.aria-valuenow]': 'mode === "determinate" ? value : null',
                    '[attr.mode]': 'mode'
                },
                inputs: ['color'],
                template: "<!--\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\n  center. The center of the circle will remain at the center of the mat-progress-spinner\n  element containing the SVG. `focusable=\"false\"` prevents IE from allowing the user to\n  tab into the SVG element.\n-->\n\n<svg\n  [style.width.px]=\"diameter\"\n  [style.height.px]=\"diameter\"\n  [attr.viewBox]=\"_viewBox\"\n  preserveAspectRatio=\"xMidYMid meet\"\n  focusable=\"false\"\n  [ngSwitch]=\"mode === 'indeterminate'\">\n\n  <!--\n    Technically we can reuse the same `circle` element, however Safari has an issue that breaks\n    the SVG rendering in determinate mode, after switching between indeterminate and determinate.\n    Using a different element avoids the issue. An alternative to this is adding `display: none`\n    for a split second and then removing it when switching between modes, but it's hard to know\n    for how long to hide the element and it can cause the UI to blink.\n  -->\n  <circle\n    *ngSwitchCase=\"true\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_circleRadius\"\n    [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + diameter\"\n    [style.stroke-dashoffset.px]=\"_strokeDashOffset\"\n    [style.stroke-dasharray.px]=\"_strokeCircumference\"\n    [style.stroke-width.%]=\"_circleStrokeWidth\"></circle>\n\n  <circle\n    *ngSwitchCase=\"false\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_circleRadius\"\n    [style.stroke-dashoffset.px]=\"_strokeDashOffset\"\n    [style.stroke-dasharray.px]=\"_strokeCircumference\"\n    [style.stroke-width.%]=\"_circleStrokeWidth\"></circle>\n</svg>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.Platform }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS]
            }] }]; }, { mode: [{
            type: Input
        }], diameter: [{
            type: Input
        }], strokeWidth: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * Tracks diameters of existing instances to de-dupe generated styles (default d = 100).
     * We need to keep track of which elements the diameters were attached to, because for
     * elements in the Shadow DOM the style tags are attached to the shadow root, rather
     * than the document head.
     * @type {?}
     * @private
     */
    MatProgressSpinner._diameters;
    /** @type {?} */
    MatProgressSpinner.ngAcceptInputType_diameter;
    /** @type {?} */
    MatProgressSpinner.ngAcceptInputType_strokeWidth;
    /** @type {?} */
    MatProgressSpinner.ngAcceptInputType_value;
    /**
     * @type {?}
     * @private
     */
    MatProgressSpinner.prototype._diameter;
    /**
     * @type {?}
     * @private
     */
    MatProgressSpinner.prototype._value;
    /**
     * @type {?}
     * @private
     */
    MatProgressSpinner.prototype._strokeWidth;
    /**
     * @type {?}
     * @private
     */
    MatProgressSpinner.prototype._fallbackAnimation;
    /**
     * Element to which we should add the generated style tags for the indeterminate animation.
     * For most elements this is the document, but for the ones in the Shadow DOM we need to
     * use the shadow root.
     * @type {?}
     * @private
     */
    MatProgressSpinner.prototype._styleRoot;
    /**
     * Whether the _mat-animation-noopable class should be applied, disabling animations.
     * @type {?}
     */
    MatProgressSpinner.prototype._noopAnimations;
    /**
     * Mode of the progress circle
     * @type {?}
     */
    MatProgressSpinner.prototype.mode;
    /** @type {?} */
    MatProgressSpinner.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MatProgressSpinner.prototype._document;
}
/**
 * `<mat-spinner>` component.
 *
 * This is a component definition to be used as a convenience reference to create an
 * indeterminate `<mat-progress-spinner>` instance.
 */
export class MatSpinner extends MatProgressSpinner {
    /**
     * @param {?} elementRef
     * @param {?} platform
     * @param {?} document
     * @param {?} animationMode
     * @param {?=} defaults
     */
    constructor(elementRef, platform, document, animationMode, defaults) {
        super(elementRef, platform, document, animationMode, defaults);
        this.mode = 'indeterminate';
    }
}
MatSpinner.ɵfac = function MatSpinner_Factory(t) { return new (t || MatSpinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS)); };
MatSpinner.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSpinner, selectors: [["mat-spinner"]], hostAttrs: ["role", "progressbar", "mode", "indeterminate", 1, "mat-spinner", "mat-progress-spinner"], hostVars: 6, hostBindings: function MatSpinner_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        ɵngcc0.ɵɵclassProp("_mat-animation-noopable", ctx._noopAnimations);
    } }, inputs: { color: "color" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function MatSpinner_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0);
        ɵngcc0.ɵɵtemplate(1, MatSpinner__svg_circle_1_Template, 1, 9, "circle", 1);
        ɵngcc0.ɵɵtemplate(2, MatSpinner__svg_circle_2_Template, 1, 7, "circle", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.diameter, "px")("height", ctx.diameter, "px");
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.mode === "indeterminate");
        ɵngcc0.ɵɵattribute("viewBox", ctx._viewBox);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", false);
    } }, directives: [ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase], styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
MatSpinner.ctorParameters = () => [
    { type: ElementRef },
    { type: Platform },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSpinner, [{
        type: Component,
        args: [{
                selector: 'mat-spinner',
                host: {
                    'role': 'progressbar',
                    'mode': 'indeterminate',
                    'class': 'mat-spinner mat-progress-spinner',
                    '[class._mat-animation-noopable]': `_noopAnimations`,
                    '[style.width.px]': 'diameter',
                    '[style.height.px]': 'diameter'
                },
                inputs: ['color'],
                template: "<!--\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\n  center. The center of the circle will remain at the center of the mat-progress-spinner\n  element containing the SVG. `focusable=\"false\"` prevents IE from allowing the user to\n  tab into the SVG element.\n-->\n\n<svg\n  [style.width.px]=\"diameter\"\n  [style.height.px]=\"diameter\"\n  [attr.viewBox]=\"_viewBox\"\n  preserveAspectRatio=\"xMidYMid meet\"\n  focusable=\"false\"\n  [ngSwitch]=\"mode === 'indeterminate'\">\n\n  <!--\n    Technically we can reuse the same `circle` element, however Safari has an issue that breaks\n    the SVG rendering in determinate mode, after switching between indeterminate and determinate.\n    Using a different element avoids the issue. An alternative to this is adding `display: none`\n    for a split second and then removing it when switching between modes, but it's hard to know\n    for how long to hide the element and it can cause the UI to blink.\n  -->\n  <circle\n    *ngSwitchCase=\"true\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_circleRadius\"\n    [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + diameter\"\n    [style.stroke-dashoffset.px]=\"_strokeDashOffset\"\n    [style.stroke-dasharray.px]=\"_strokeCircumference\"\n    [style.stroke-width.%]=\"_circleStrokeWidth\"></circle>\n\n  <circle\n    *ngSwitchCase=\"false\"\n    cx=\"50%\"\n    cy=\"50%\"\n    [attr.r]=\"_circleRadius\"\n    [style.stroke-dashoffset.px]=\"_strokeDashOffset\"\n    [style.stroke-dasharray.px]=\"_strokeCircumference\"\n    [style.stroke-width.%]=\"_circleStrokeWidth\"></circle>\n</svg>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.Platform }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS]
            }] }]; }, null); })();
/**
 * Gets the shadow root of an element, if supported and the element is inside the Shadow DOM.
 * @param {?} element
 * @param {?} _document
 * @return {?}
 */
export function _getShadowRoot(element, _document) {
    // TODO(crisbeto): see whether we should move this into the CDK
    // feature detection utilities once #15616 gets merged in.
    if (typeof window !== 'undefined') {
        /** @type {?} */
        const head = _document.head;
        // Check whether the browser supports Shadow DOM.
        if (head && (((/** @type {?} */ (head))).createShadowRoot || head.attachShadow)) {
            /** @type {?} */
            const rootNode = element.getRootNode ? element.getRootNode() : null;
            // We need to take the `ShadowRoot` off of `window`, because the built-in types are
            // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.
            if (rootNode instanceof ((/** @type {?} */ (window))).ShadowRoot) {
                return rootNode;
            }
        }
    }
    return null;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L2ZpbmFsMy9jdXJzb3Mvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL21hdGVyaWFsL2VzbTIwMTUvcHJvZ3Jlc3Mtc3Bpbm5lci9wcm9ncmVzcy1zcGlubmVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aXdHQW9SQzs7Ozs7Ozs4Q0FPNkMsQUFzQjVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQWNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUZELGd3R0FrQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBUUEiLCJmaWxlIjoicHJvZ3Jlc3Mtc3Bpbm5lci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBHZW5lcmF0ZWQgZnJvbTogc3JjL21hdGVyaWFsL3Byb2dyZXNzLXNwaW5uZXIvcHJvZ3Jlc3Mtc3Bpbm5lci50c1xuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IGNvZXJjZU51bWJlclByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIElucHV0LCBPcHRpb25hbCwgVmlld0VuY2Fwc3VsYXRpb24sIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBtaXhpbkNvbG9yIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XG5pbXBvcnQgeyBBTklNQVRJT05fTU9EVUxFX1RZUEUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2FuaW1hdGlvbnMnO1xuLyoqXG4gKiBCYXNlIHJlZmVyZW5jZSBzaXplIG9mIHRoZSBzcGlubmVyLlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAdHlwZSB7P31cbiAqL1xuY29uc3QgQkFTRV9TSVpFID0gMTAwO1xuLyoqXG4gKiBCYXNlIHJlZmVyZW5jZSBzdHJva2Ugd2lkdGggb2YgdGhlIHNwaW5uZXIuXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqIEB0eXBlIHs/fVxuICovXG5jb25zdCBCQVNFX1NUUk9LRV9XSURUSCA9IDEwO1xuLy8gQm9pbGVycGxhdGUgZm9yIGFwcGx5aW5nIG1peGlucyB0byBNYXRQcm9ncmVzc1NwaW5uZXIuXG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICovXG5jbGFzcyBNYXRQcm9ncmVzc1NwaW5uZXJCYXNlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgIH1cbn1cbmlmIChmYWxzZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBNYXRQcm9ncmVzc1NwaW5uZXJCYXNlLnByb3RvdHlwZS5fZWxlbWVudFJlZjtcbn1cbi8qKiBAdHlwZSB7P30gKi9cbmNvbnN0IF9NYXRQcm9ncmVzc1NwaW5uZXJNaXhpbkJhc2UgPSBtaXhpbkNvbG9yKE1hdFByb2dyZXNzU3Bpbm5lckJhc2UsICdwcmltYXJ5Jyk7XG4vKipcbiAqIERlZmF1bHQgYG1hdC1wcm9ncmVzcy1zcGlubmVyYCBvcHRpb25zIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4uXG4gKiBAcmVjb3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNYXRQcm9ncmVzc1NwaW5uZXJEZWZhdWx0T3B0aW9ucygpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogRGlhbWV0ZXIgb2YgdGhlIHNwaW5uZXIuXG4gICAgICogQHR5cGUgez98dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIE1hdFByb2dyZXNzU3Bpbm5lckRlZmF1bHRPcHRpb25zLnByb3RvdHlwZS5kaWFtZXRlcjtcbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgc3Bpbm5lcidzIHN0cm9rZS5cbiAgICAgKiBAdHlwZSB7P3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgTWF0UHJvZ3Jlc3NTcGlubmVyRGVmYXVsdE9wdGlvbnMucHJvdG90eXBlLnN0cm9rZVdpZHRoO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGFuaW1hdGlvbnMgc2hvdWxkIGJlIGZvcmNlIHRvIGJlIGVuYWJsZWQsIGlnbm9yaW5nIGlmIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzXG4gICAgICogdXNpbmcgTm9vcEFuaW1hdGlvbnNNb2R1bGUuXG4gICAgICogQHR5cGUgez98dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIE1hdFByb2dyZXNzU3Bpbm5lckRlZmF1bHRPcHRpb25zLnByb3RvdHlwZS5fZm9yY2VBbmltYXRpb25zO1xufVxuLyoqXG4gKiBJbmplY3Rpb24gdG9rZW4gdG8gYmUgdXNlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBgbWF0LXByb2dyZXNzLXNwaW5uZXJgLlxuICogQHR5cGUgez99XG4gKi9cbmV4cG9ydCBjb25zdCBNQVRfUFJPR1JFU1NfU1BJTk5FUl9ERUZBVUxUX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ21hdC1wcm9ncmVzcy1zcGlubmVyLWRlZmF1bHQtb3B0aW9ucycsIHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgZmFjdG9yeTogTUFUX1BST0dSRVNTX1NQSU5ORVJfREVGQVVMVF9PUFRJT05TX0ZBQ1RPUlksXG59KTtcbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gTUFUX1BST0dSRVNTX1NQSU5ORVJfREVGQVVMVF9PUFRJT05TX0ZBQ1RPUlkoKSB7XG4gICAgcmV0dXJuIHsgZGlhbWV0ZXI6IEJBU0VfU0laRSB9O1xufVxuLy8gLjAwMDEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBhdm9pZCB1bndhbnRlZCBhbmltYXRpb24gZnJhbWVzXG4vLyBmb3IgZXhhbXBsZSBiZWNhdXNlIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaXMgNCBzZWNvbmRzLCAuMSUgYWNjb3VudHMgdG8gNG1zXG4vLyB3aGljaCBhcmUgZW5vdWdoIHRvIHNlZSB0aGUgZmxpY2tlciBkZXNjcmliZWQgaW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NvbXBvbmVudHMvaXNzdWVzLzg5ODRcbi8qKiBAdHlwZSB7P30gKi9cbmNvbnN0IElOREVURVJNSU5BVEVfQU5JTUFUSU9OX1RFTVBMQVRFID0gYFxuIEBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLXNwaW5uZXItc3Ryb2tlLXJvdGF0ZS1ESUFNRVRFUiB7XG4gICAgMCUgICAgICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTsgIHRyYW5zZm9ybTogcm90YXRlKDApOyB9XG4gICAgMTIuNSUgICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBFTkRfVkFMVUU7ICAgIHRyYW5zZm9ybTogcm90YXRlKDApOyB9XG4gICAgMTIuNTAwMSUgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IEVORF9WQUxVRTsgICAgdHJhbnNmb3JtOiByb3RhdGVYKDE4MGRlZykgcm90YXRlKDcyLjVkZWcpOyB9XG4gICAgMjUlICAgICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTsgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSg3Mi41ZGVnKTsgfVxuXG4gICAgMjUuMDAwMSUgICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTsgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7IH1cbiAgICAzNy41JSAgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IEVORF9WQUxVRTsgICAgdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTsgfVxuICAgIDM3LjUwMDElICB7IHN0cm9rZS1kYXNob2Zmc2V0OiBFTkRfVkFMVUU7ICAgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSgxNjEuNWRlZyk7IH1cbiAgICA1MCUgICAgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IFNUQVJUX1ZBTFVFOyAgdHJhbnNmb3JtOiByb3RhdGVYKDE4MGRlZykgcm90YXRlKDE2MS41ZGVnKTsgfVxuXG4gICAgNTAuMDAwMSUgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IFNUQVJUX1ZBTFVFOyAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxuICAgIDYyLjUlICAgeyBzdHJva2UtZGFzaG9mZnNldDogRU5EX1ZBTFVFOyAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpOyB9XG4gICAgNjIuNTAwMSUgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IEVORF9WQUxVRTsgICAgdHJhbnNmb3JtOiByb3RhdGVYKDE4MGRlZykgcm90YXRlKDI1MS41ZGVnKTsgfVxuICAgIDc1JSAgICAgeyBzdHJva2UtZGFzaG9mZnNldDogU1RBUlRfVkFMVUU7ICB0cmFuc2Zvcm06IHJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMjUxLjVkZWcpOyB9XG5cbiAgICA3NS4wMDAxJSAgeyBzdHJva2UtZGFzaG9mZnNldDogU1RBUlRfVkFMVUU7ICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7IH1cbiAgICA4Ny41JSAgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IEVORF9WQUxVRTsgICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpOyB9XG4gICAgODcuNTAwMSUgIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IEVORF9WQUxVRTsgICAgdHJhbnNmb3JtOiByb3RhdGVYKDE4MGRlZykgcm90YXRlKDM0MS41ZGVnKTsgfVxuICAgIDEwMCUgICAgeyBzdHJva2UtZGFzaG9mZnNldDogU1RBUlRfVkFMVUU7ICB0cmFuc2Zvcm06IHJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMzQxLjVkZWcpOyB9XG4gIH1cbmA7XG4vKipcbiAqIGA8bWF0LXByb2dyZXNzLXNwaW5uZXI+YCBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRQcm9ncmVzc1NwaW5uZXIgZXh0ZW5kcyBfTWF0UHJvZ3Jlc3NTcGlubmVyTWl4aW5CYXNlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBwbGF0Zm9ybVxuICAgICAqIEBwYXJhbSB7P30gX2RvY3VtZW50XG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25Nb2RlXG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudFJlZiwgcGxhdGZvcm0sIF9kb2N1bWVudCwgYW5pbWF0aW9uTW9kZSwgZGVmYXVsdHMpIHtcbiAgICAgICAgc3VwZXIoX2VsZW1lbnRSZWYpO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gX2RvY3VtZW50O1xuICAgICAgICB0aGlzLl9kaWFtZXRlciA9IEJBU0VfU0laRTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl9mYWxsYmFja0FuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZSBvZiB0aGUgcHJvZ3Jlc3MgY2lyY2xlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGUgPSAnZGV0ZXJtaW5hdGUnO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHRyYWNrZWREaWFtZXRlcnMgPSBNYXRQcm9ncmVzc1NwaW5uZXIuX2RpYW1ldGVycztcbiAgICAgICAgLy8gVGhlIGJhc2Ugc2l6ZSBpcyBhbHJlYWR5IGluc2VydGVkIHZpYSB0aGUgY29tcG9uZW50J3Mgc3RydWN0dXJhbCBzdHlsZXMuIFdlIHN0aWxsXG4gICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgaXQgc28gd2UgZG9uJ3QgZW5kIHVwIGFkZGluZyB0aGUgc2FtZSBzdHlsZXMgYWdhaW4uXG4gICAgICAgIGlmICghdHJhY2tlZERpYW1ldGVycy5oYXMoX2RvY3VtZW50LmhlYWQpKSB7XG4gICAgICAgICAgICB0cmFja2VkRGlhbWV0ZXJzLnNldChfZG9jdW1lbnQuaGVhZCwgbmV3IFNldChbQkFTRV9TSVpFXSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZhbGxiYWNrQW5pbWF0aW9uID0gcGxhdGZvcm0uRURHRSB8fCBwbGF0Zm9ybS5UUklERU5UO1xuICAgICAgICB0aGlzLl9ub29wQW5pbWF0aW9ucyA9IGFuaW1hdGlvbk1vZGUgPT09ICdOb29wQW5pbWF0aW9ucycgJiZcbiAgICAgICAgICAgICghIWRlZmF1bHRzICYmICFkZWZhdWx0cy5fZm9yY2VBbmltYXRpb25zKTtcbiAgICAgICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuZGlhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYW1ldGVyID0gZGVmYXVsdHMuZGlhbWV0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gZGVmYXVsdHMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRpYW1ldGVyIG9mIHRoZSBwcm9ncmVzcyBzcGlubmVyICh3aWxsIHNldCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHN2ZykuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgZGlhbWV0ZXIoKSB7IHJldHVybiB0aGlzLl9kaWFtZXRlcjsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2l6ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2V0IGRpYW1ldGVyKHNpemUpIHtcbiAgICAgICAgdGhpcy5fZGlhbWV0ZXIgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eShzaXplKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBzZXQgYmVmb3JlIGBuZ09uSW5pdGAsIHRoZSBzdHlsZSByb290IG1heSBub3QgaGF2ZSBiZWVuIHJlc29sdmVkIHlldC5cbiAgICAgICAgaWYgKCF0aGlzLl9mYWxsYmFja0FuaW1hdGlvbiAmJiB0aGlzLl9zdHlsZVJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaFN0eWxlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cm9rZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3Mgc3Bpbm5lci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBzdHJva2VXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZVdpZHRoIHx8IHRoaXMuZGlhbWV0ZXIgLyAxMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2V0IHN0cm9rZVdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0cm9rZVdpZHRoID0gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgY2lyY2xlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnID8gdGhpcy5fdmFsdWUgOiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5ld1ZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIGNvZXJjZU51bWJlclByb3BlcnR5KG5ld1ZhbHVlKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIHJvb3Qgbm9kZSBpbiBuZ09uSW5pdCwgcmF0aGVyIHRoYW4gdGhlIGNvbnN0cnVjdG9yLCBiZWNhdXNlXG4gICAgICAgIC8vIEFuZ3VsYXIgc2VlbXMgdG8gY3JlYXRlIHRoZSBlbGVtZW50IG91dHNpZGUgdGhlIHNoYWRvdyByb290IGFuZCB0aGVuIG1vdmVzIGl0IGluc2lkZSwgaWYgdGhlXG4gICAgICAgIC8vIG5vZGUgaXMgaW5zaWRlIGFuIGBuZ0lmYCBhbmQgYSBTaGFkb3dEb20tZW5jYXBzdWxhdGVkIGNvbXBvbmVudC5cbiAgICAgICAgdGhpcy5fc3R5bGVSb290ID0gX2dldFNoYWRvd1Jvb3QoZWxlbWVudCwgdGhpcy5fZG9jdW1lbnQpIHx8IHRoaXMuX2RvY3VtZW50LmhlYWQ7XG4gICAgICAgIHRoaXMuX2F0dGFjaFN0eWxlTm9kZSgpO1xuICAgICAgICAvLyBPbiBJRSBhbmQgRWRnZSwgd2UgY2FuJ3QgYW5pbWF0ZSB0aGUgYHN0cm9rZS1kYXNob2Zmc2V0YFxuICAgICAgICAvLyByZWxpYWJseSBzbyB3ZSBmYWxsIGJhY2sgdG8gYSBub24tc3BlYyBhbmltYXRpb24uXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uQ2xhc3MgPSBgbWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZSR7dGhpcy5fZmFsbGJhY2tBbmltYXRpb24gPyAnLWZhbGxiYWNrJyA6ICcnfS1hbmltYXRpb25gO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoYW5pbWF0aW9uQ2xhc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoZSBzcGlubmVyLCBhZGp1c3RlZCBmb3Igc3Ryb2tlIHdpZHRoLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IF9jaXJjbGVSYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kaWFtZXRlciAtIEJBU0VfU1RST0tFX1dJRFRIKSAvIDI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB2aWV3IGJveCBvZiB0aGUgc3Bpbm5lcidzIHN2ZyBlbGVtZW50LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IF92aWV3Qm94KCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHZpZXdCb3ggPSB0aGlzLl9jaXJjbGVSYWRpdXMgKiAyICsgdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgcmV0dXJuIGAwIDAgJHt2aWV3Qm94fSAke3ZpZXdCb3h9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHN0cm9rZSBjaXJjdW1mZXJlbmNlIG9mIHRoZSBzdmcgY2lyY2xlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IF9zdHJva2VDaXJjdW1mZXJlbmNlKCkge1xuICAgICAgICByZXR1cm4gMiAqIE1hdGguUEkgKiB0aGlzLl9jaXJjbGVSYWRpdXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkYXNoIG9mZnNldCBvZiB0aGUgc3ZnIGNpcmNsZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBfc3Ryb2tlRGFzaE9mZnNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2RldGVybWluYXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZUNpcmN1bWZlcmVuY2UgKiAoMTAwIC0gdGhpcy5fdmFsdWUpIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGZhbGxiYWNrIG1vZGUgc2V0IHRoZSBjaXJjbGUgdG8gODAlIGFuZCByb3RhdGUgaXQgd2l0aCBDU1MuXG4gICAgICAgIGlmICh0aGlzLl9mYWxsYmFja0FuaW1hdGlvbiAmJiB0aGlzLm1vZGUgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZUNpcmN1bWZlcmVuY2UgKiAwLjI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cm9rZSB3aWR0aCBvZiB0aGUgY2lyY2xlIGluIHBlcmNlbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgX2NpcmNsZVN0cm9rZVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VXaWR0aCAvIHRoaXMuZGlhbWV0ZXIgKiAxMDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIER5bmFtaWNhbGx5IGdlbmVyYXRlcyBhIHN0eWxlIHRhZyBjb250YWluaW5nIHRoZSBjb3JyZWN0IGFuaW1hdGlvbiBmb3IgdGhpcyBkaWFtZXRlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2F0dGFjaFN0eWxlTm9kZSgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBzdHlsZVJvb3QgPSB0aGlzLl9zdHlsZVJvb3Q7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgY3VycmVudERpYW1ldGVyID0gdGhpcy5fZGlhbWV0ZXI7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgZGlhbWV0ZXJzID0gTWF0UHJvZ3Jlc3NTcGlubmVyLl9kaWFtZXRlcnM7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgbGV0IGRpYW1ldGVyc0ZvckVsZW1lbnQgPSBkaWFtZXRlcnMuZ2V0KHN0eWxlUm9vdCk7XG4gICAgICAgIGlmICghZGlhbWV0ZXJzRm9yRWxlbWVudCB8fCAhZGlhbWV0ZXJzRm9yRWxlbWVudC5oYXMoY3VycmVudERpYW1ldGVyKSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVUYWcgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdtYXQtc3Bpbm5lci1hbmltYXRpb24nLCBjdXJyZW50RGlhbWV0ZXIgKyAnJyk7XG4gICAgICAgICAgICBzdHlsZVRhZy50ZXh0Q29udGVudCA9IHRoaXMuX2dldEFuaW1hdGlvblRleHQoKTtcbiAgICAgICAgICAgIHN0eWxlUm9vdC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG4gICAgICAgICAgICBpZiAoIWRpYW1ldGVyc0ZvckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkaWFtZXRlcnNGb3JFbGVtZW50ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGRpYW1ldGVycy5zZXQoc3R5bGVSb290LCBkaWFtZXRlcnNGb3JFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpYW1ldGVyc0ZvckVsZW1lbnQuYWRkKGN1cnJlbnREaWFtZXRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuaW1hdGlvbiBzdHlsZXMgYWRqdXN0ZWQgZm9yIHRoZSBzcGlubmVyJ3MgZGlhbWV0ZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9nZXRBbmltYXRpb25UZXh0KCkge1xuICAgICAgICByZXR1cm4gSU5ERVRFUk1JTkFURV9BTklNQVRJT05fVEVNUExBVEVcbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiBzaG91bGQgYmVnaW4gYXQgNSUgYW5kIGVuZCBhdCA4MCVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9TVEFSVF9WQUxVRS9nLCBgJHswLjk1ICogdGhpcy5fc3Ryb2tlQ2lyY3VtZmVyZW5jZX1gKVxuICAgICAgICAgICAgLnJlcGxhY2UoL0VORF9WQUxVRS9nLCBgJHswLjIgKiB0aGlzLl9zdHJva2VDaXJjdW1mZXJlbmNlfWApXG4gICAgICAgICAgICAucmVwbGFjZSgvRElBTUVURVIvZywgYCR7dGhpcy5kaWFtZXRlcn1gKTtcbiAgICB9XG59XG4vKipcbiAqIFRyYWNrcyBkaWFtZXRlcnMgb2YgZXhpc3RpbmcgaW5zdGFuY2VzIHRvIGRlLWR1cGUgZ2VuZXJhdGVkIHN0eWxlcyAoZGVmYXVsdCBkID0gMTAwKS5cbiAqIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBlbGVtZW50cyB0aGUgZGlhbWV0ZXJzIHdlcmUgYXR0YWNoZWQgdG8sIGJlY2F1c2UgZm9yXG4gKiBlbGVtZW50cyBpbiB0aGUgU2hhZG93IERPTSB0aGUgc3R5bGUgdGFncyBhcmUgYXR0YWNoZWQgdG8gdGhlIHNoYWRvdyByb290LCByYXRoZXJcbiAqIHRoYW4gdGhlIGRvY3VtZW50IGhlYWQuXG4gKi9cbk1hdFByb2dyZXNzU3Bpbm5lci5fZGlhbWV0ZXJzID0gbmV3IFdlYWtNYXAoKTtcbk1hdFByb2dyZXNzU3Bpbm5lci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWF0LXByb2dyZXNzLXNwaW5uZXInLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbWF0UHJvZ3Jlc3NTcGlubmVyJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1wcm9ncmVzcy1zcGlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZV0nOiBgX25vb3BBbmltYXRpb25zYCxcbiAgICAgICAgICAgICAgICAgICAgJ1tzdHlsZS53aWR0aC5weF0nOiAnZGlhbWV0ZXInLFxuICAgICAgICAgICAgICAgICAgICAnW3N0eWxlLmhlaWdodC5weF0nOiAnZGlhbWV0ZXInLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW1pbl0nOiAnbW9kZSA9PT0gXCJkZXRlcm1pbmF0ZVwiID8gMCA6IG51bGwnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW1heF0nOiAnbW9kZSA9PT0gXCJkZXRlcm1pbmF0ZVwiID8gMTAwIDogbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbm93XSc6ICdtb2RlID09PSBcImRldGVybWluYXRlXCIgPyB2YWx1ZSA6IG51bGwnLFxuICAgICAgICAgICAgICAgICAgICAnW2F0dHIubW9kZV0nOiAnbW9kZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sb3InXSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8IS0tXFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvIG9mIHhNaWRZTWlkIG1lZXQgYXMgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgaXMgdGhlIGNpcmNsZSdzXFxuICBjZW50ZXIuIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSB3aWxsIHJlbWFpbiBhdCB0aGUgY2VudGVyIG9mIHRoZSBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lclxcbiAgZWxlbWVudCBjb250YWluaW5nIHRoZSBTVkcuIGBmb2N1c2FibGU9XFxcImZhbHNlXFxcImAgcHJldmVudHMgSUUgZnJvbSBhbGxvd2luZyB0aGUgdXNlciB0b1xcbiAgdGFiIGludG8gdGhlIFNWRyBlbGVtZW50Llxcbi0tPlxcblxcbjxzdmdcXG4gIFtzdHlsZS53aWR0aC5weF09XFxcImRpYW1ldGVyXFxcIlxcbiAgW3N0eWxlLmhlaWdodC5weF09XFxcImRpYW1ldGVyXFxcIlxcbiAgW2F0dHIudmlld0JveF09XFxcIl92aWV3Qm94XFxcIlxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCJcXG4gIGZvY3VzYWJsZT1cXFwiZmFsc2VcXFwiXFxuICBbbmdTd2l0Y2hdPVxcXCJtb2RlID09PSAnaW5kZXRlcm1pbmF0ZSdcXFwiPlxcblxcbiAgPCEtLVxcbiAgICBUZWNobmljYWxseSB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgYGNpcmNsZWAgZWxlbWVudCwgaG93ZXZlciBTYWZhcmkgaGFzIGFuIGlzc3VlIHRoYXQgYnJlYWtzXFxuICAgIHRoZSBTVkcgcmVuZGVyaW5nIGluIGRldGVybWluYXRlIG1vZGUsIGFmdGVyIHN3aXRjaGluZyBiZXR3ZWVuIGluZGV0ZXJtaW5hdGUgYW5kIGRldGVybWluYXRlLlxcbiAgICBVc2luZyBhIGRpZmZlcmVudCBlbGVtZW50IGF2b2lkcyB0aGUgaXNzdWUuIEFuIGFsdGVybmF0aXZlIHRvIHRoaXMgaXMgYWRkaW5nIGBkaXNwbGF5OiBub25lYFxcbiAgICBmb3IgYSBzcGxpdCBzZWNvbmQgYW5kIHRoZW4gcmVtb3ZpbmcgaXQgd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBtb2RlcywgYnV0IGl0J3MgaGFyZCB0byBrbm93XFxuICAgIGZvciBob3cgbG9uZyB0byBoaWRlIHRoZSBlbGVtZW50IGFuZCBpdCBjYW4gY2F1c2UgdGhlIFVJIHRvIGJsaW5rLlxcbiAgLS0+XFxuICA8Y2lyY2xlXFxuICAgICpuZ1N3aXRjaENhc2U9XFxcInRydWVcXFwiXFxuICAgIGN4PVxcXCI1MCVcXFwiXFxuICAgIGN5PVxcXCI1MCVcXFwiXFxuICAgIFthdHRyLnJdPVxcXCJfY2lyY2xlUmFkaXVzXFxcIlxcbiAgICBbc3R5bGUuYW5pbWF0aW9uLW5hbWVdPVxcXCInbWF0LXByb2dyZXNzLXNwaW5uZXItc3Ryb2tlLXJvdGF0ZS0nICsgZGlhbWV0ZXJcXFwiXFxuICAgIFtzdHlsZS5zdHJva2UtZGFzaG9mZnNldC5weF09XFxcIl9zdHJva2VEYXNoT2Zmc2V0XFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLWRhc2hhcnJheS5weF09XFxcIl9zdHJva2VDaXJjdW1mZXJlbmNlXFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoLiVdPVxcXCJfY2lyY2xlU3Ryb2tlV2lkdGhcXFwiPjwvY2lyY2xlPlxcblxcbiAgPGNpcmNsZVxcbiAgICAqbmdTd2l0Y2hDYXNlPVxcXCJmYWxzZVxcXCJcXG4gICAgY3g9XFxcIjUwJVxcXCJcXG4gICAgY3k9XFxcIjUwJVxcXCJcXG4gICAgW2F0dHIucl09XFxcIl9jaXJjbGVSYWRpdXNcXFwiXFxuICAgIFtzdHlsZS5zdHJva2UtZGFzaG9mZnNldC5weF09XFxcIl9zdHJva2VEYXNoT2Zmc2V0XFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLWRhc2hhcnJheS5weF09XFxcIl9zdHJva2VDaXJjdW1mZXJlbmNlXFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoLiVdPVxcXCJfY2lyY2xlU3Ryb2tlV2lkdGhcXFwiPjwvY2lyY2xlPlxcbjwvc3ZnPlxcblwiLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXByb2dyZXNzLXNwaW5uZXJ7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIgc3Zne3Bvc2l0aW9uOmFic29sdXRlO3RyYW5zZm9ybTpyb3RhdGUoLTkwZGVnKTt0b3A6MDtsZWZ0OjA7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7b3ZlcmZsb3c6dmlzaWJsZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIgY2lyY2xle2ZpbGw6dHJhbnNwYXJlbnQ7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7dHJhbnNpdGlvbjpzdHJva2UtZGFzaG9mZnNldCAyMjVtcyBsaW5lYXJ9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1wcm9ncmVzcy1zcGlubmVyIGNpcmNsZXt0cmFuc2l0aW9uOm5vbmU7YW5pbWF0aW9uOm5vbmV9Lm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV17YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGUgMjAwMG1zIGxpbmVhciBpbmZpbml0ZX0uX21hdC1hbmltYXRpb24tbm9vcGFibGUubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXXt0cmFuc2l0aW9uOm5vbmU7YW5pbWF0aW9uOm5vbmV9Lm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV0gY2lyY2xle3RyYW5zaXRpb24tcHJvcGVydHk6c3Ryb2tlO2FuaW1hdGlvbi1kdXJhdGlvbjo0MDAwbXM7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSk7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZX0uX21hdC1hbmltYXRpb24tbm9vcGFibGUubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXSBjaXJjbGV7dHJhbnNpdGlvbjpub25lO2FuaW1hdGlvbjpub25lfS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1pbmRldGVybWluYXRlLWZhbGxiYWNrLWFuaW1hdGlvblttb2RlPWluZGV0ZXJtaW5hdGVde2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHJva2Utcm90YXRlLWZhbGxiYWNrIDEwMDAwbXMgY3ViaWMtYmV6aWVyKDAuODcsIDAuMDMsIDAuMzMsIDEpIGluZmluaXRlfS5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1pbmRldGVybWluYXRlLWZhbGxiYWNrLWFuaW1hdGlvblttb2RlPWluZGV0ZXJtaW5hdGVde3RyYW5zaXRpb246bm9uZTthbmltYXRpb246bm9uZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1mYWxsYmFjay1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXSBjaXJjbGV7dHJhbnNpdGlvbi1wcm9wZXJ0eTpzdHJva2V9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtZmFsbGJhY2stYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV0gY2lyY2xle3RyYW5zaXRpb246bm9uZTthbmltYXRpb246bm9uZX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGV7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHJva2Utcm90YXRlLTEwMHswJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMi41JXtzdHJva2UtZGFzaG9mZnNldDo1Ni41NDg2Njc3cHg7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMi41MDAxJXtzdHJva2UtZGFzaG9mZnNldDo1Ni41NDg2Njc3cHg7dHJhbnNmb3JtOnJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoNzIuNWRlZyl9MjUle3N0cm9rZS1kYXNob2Zmc2V0OjI2OC42MDYxNzE1NzVweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSg3Mi41ZGVnKX0yNS4wMDAxJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpfTM3LjUle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlKDI3MGRlZyl9MzcuNTAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDE2MS41ZGVnKX01MCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDE2MS41ZGVnKX01MC4wMDAxJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfTYyLjUle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZyl9NjIuNTAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDI1MS41ZGVnKX03NSV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDI1MS41ZGVnKX03NS4wMDAxJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyl9ODcuNSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfTg3LjUwMDEle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSgzNDEuNWRlZyl9MTAwJXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMzQxLjVkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLXN0cm9rZS1yb3RhdGUtZmFsbGJhY2t7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKX0yNSV7dHJhbnNmb3JtOnJvdGF0ZSgxMTcwZGVnKX01MCV7dHJhbnNmb3JtOnJvdGF0ZSgyMzQwZGVnKX03NSV7dHJhbnNmb3JtOnJvdGF0ZSgzNTEwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoNDY4MGRlZyl9fVxcblwiXVxuICAgICAgICAgICAgfV0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTWF0UHJvZ3Jlc3NTcGlubmVyLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogUGxhdGZvcm0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH1dIH0sXG4gICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbQU5JTUFUSU9OX01PRFVMRV9UWVBFLF0gfV0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTUFUX1BST0dSRVNTX1NQSU5ORVJfREVGQVVMVF9PUFRJT05TLF0gfV0gfVxuXTtcbk1hdFByb2dyZXNzU3Bpbm5lci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBkaWFtZXRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3Ryb2tlV2lkdGg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1vZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIFRyYWNrcyBkaWFtZXRlcnMgb2YgZXhpc3RpbmcgaW5zdGFuY2VzIHRvIGRlLWR1cGUgZ2VuZXJhdGVkIHN0eWxlcyAoZGVmYXVsdCBkID0gMTAwKS5cbiAgICAgKiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgdGhlIGRpYW1ldGVycyB3ZXJlIGF0dGFjaGVkIHRvLCBiZWNhdXNlIGZvclxuICAgICAqIGVsZW1lbnRzIGluIHRoZSBTaGFkb3cgRE9NIHRoZSBzdHlsZSB0YWdzIGFyZSBhdHRhY2hlZCB0byB0aGUgc2hhZG93IHJvb3QsIHJhdGhlclxuICAgICAqIHRoYW4gdGhlIGRvY3VtZW50IGhlYWQuXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNYXRQcm9ncmVzc1NwaW5uZXIuX2RpYW1ldGVycztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTWF0UHJvZ3Jlc3NTcGlubmVyLm5nQWNjZXB0SW5wdXRUeXBlX2RpYW1ldGVyO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBNYXRQcm9ncmVzc1NwaW5uZXIubmdBY2NlcHRJbnB1dFR5cGVfc3Ryb2tlV2lkdGg7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdFByb2dyZXNzU3Bpbm5lci5uZ0FjY2VwdElucHV0VHlwZV92YWx1ZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX2RpYW1ldGVyO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWF0UHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5fdmFsdWU7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNYXRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLl9zdHJva2VXaWR0aDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX2ZhbGxiYWNrQW5pbWF0aW9uO1xuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgdG8gd2hpY2ggd2Ugc2hvdWxkIGFkZCB0aGUgZ2VuZXJhdGVkIHN0eWxlIHRhZ3MgZm9yIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbi5cbiAgICAgKiBGb3IgbW9zdCBlbGVtZW50cyB0aGlzIGlzIHRoZSBkb2N1bWVudCwgYnV0IGZvciB0aGUgb25lcyBpbiB0aGUgU2hhZG93IERPTSB3ZSBuZWVkIHRvXG4gICAgICogdXNlIHRoZSBzaGFkb3cgcm9vdC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX3N0eWxlUm9vdDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBfbWF0LWFuaW1hdGlvbi1ub29wYWJsZSBjbGFzcyBzaG91bGQgYmUgYXBwbGllZCwgZGlzYWJsaW5nIGFuaW1hdGlvbnMuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0UHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5fbm9vcEFuaW1hdGlvbnM7XG4gICAgLyoqXG4gICAgICogTW9kZSBvZiB0aGUgcHJvZ3Jlc3MgY2lyY2xlXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0UHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5tb2RlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBNYXRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLl9lbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWF0UHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5fZG9jdW1lbnQ7XG59XG4vKipcbiAqIGA8bWF0LXNwaW5uZXI+YCBjb21wb25lbnQuXG4gKlxuICogVGhpcyBpcyBhIGNvbXBvbmVudCBkZWZpbml0aW9uIHRvIGJlIHVzZWQgYXMgYSBjb252ZW5pZW5jZSByZWZlcmVuY2UgdG8gY3JlYXRlIGFuXG4gKiBpbmRldGVybWluYXRlIGA8bWF0LXByb2dyZXNzLXNwaW5uZXI+YCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hdFNwaW5uZXIgZXh0ZW5kcyBNYXRQcm9ncmVzc1NwaW5uZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez99IGRvY3VtZW50XG4gICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25Nb2RlXG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCBwbGF0Zm9ybSwgZG9jdW1lbnQsIGFuaW1hdGlvbk1vZGUsIGRlZmF1bHRzKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnRSZWYsIHBsYXRmb3JtLCBkb2N1bWVudCwgYW5pbWF0aW9uTW9kZSwgZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLm1vZGUgPSAnaW5kZXRlcm1pbmF0ZSc7XG4gICAgfVxufVxuTWF0U3Bpbm5lci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWF0LXNwaW5uZXInLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxuICAgICAgICAgICAgICAgICAgICAnbW9kZSc6ICdpbmRldGVybWluYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1zcGlubmVyIG1hdC1wcm9ncmVzcy1zcGlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZV0nOiBgX25vb3BBbmltYXRpb25zYCxcbiAgICAgICAgICAgICAgICAgICAgJ1tzdHlsZS53aWR0aC5weF0nOiAnZGlhbWV0ZXInLFxuICAgICAgICAgICAgICAgICAgICAnW3N0eWxlLmhlaWdodC5weF0nOiAnZGlhbWV0ZXInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2NvbG9yJ10sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPCEtLVxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbyBvZiB4TWlkWU1pZCBtZWV0IGFzIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0IGlzIHRoZSBjaXJjbGUnc1xcbiAgY2VudGVyLiBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgd2lsbCByZW1haW4gYXQgdGhlIGNlbnRlciBvZiB0aGUgbWF0LXByb2dyZXNzLXNwaW5uZXJcXG4gIGVsZW1lbnQgY29udGFpbmluZyB0aGUgU1ZHLiBgZm9jdXNhYmxlPVxcXCJmYWxzZVxcXCJgIHByZXZlbnRzIElFIGZyb20gYWxsb3dpbmcgdGhlIHVzZXIgdG9cXG4gIHRhYiBpbnRvIHRoZSBTVkcgZWxlbWVudC5cXG4tLT5cXG5cXG48c3ZnXFxuICBbc3R5bGUud2lkdGgucHhdPVxcXCJkaWFtZXRlclxcXCJcXG4gIFtzdHlsZS5oZWlnaHQucHhdPVxcXCJkaWFtZXRlclxcXCJcXG4gIFthdHRyLnZpZXdCb3hdPVxcXCJfdmlld0JveFxcXCJcXG4gIHByZXNlcnZlQXNwZWN0UmF0aW89XFxcInhNaWRZTWlkIG1lZXRcXFwiXFxuICBmb2N1c2FibGU9XFxcImZhbHNlXFxcIlxcbiAgW25nU3dpdGNoXT1cXFwibW9kZSA9PT0gJ2luZGV0ZXJtaW5hdGUnXFxcIj5cXG5cXG4gIDwhLS1cXG4gICAgVGVjaG5pY2FsbHkgd2UgY2FuIHJldXNlIHRoZSBzYW1lIGBjaXJjbGVgIGVsZW1lbnQsIGhvd2V2ZXIgU2FmYXJpIGhhcyBhbiBpc3N1ZSB0aGF0IGJyZWFrc1xcbiAgICB0aGUgU1ZHIHJlbmRlcmluZyBpbiBkZXRlcm1pbmF0ZSBtb2RlLCBhZnRlciBzd2l0Y2hpbmcgYmV0d2VlbiBpbmRldGVybWluYXRlIGFuZCBkZXRlcm1pbmF0ZS5cXG4gICAgVXNpbmcgYSBkaWZmZXJlbnQgZWxlbWVudCBhdm9pZHMgdGhlIGlzc3VlLiBBbiBhbHRlcm5hdGl2ZSB0byB0aGlzIGlzIGFkZGluZyBgZGlzcGxheTogbm9uZWBcXG4gICAgZm9yIGEgc3BsaXQgc2Vjb25kIGFuZCB0aGVuIHJlbW92aW5nIGl0IHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gbW9kZXMsIGJ1dCBpdCdzIGhhcmQgdG8ga25vd1xcbiAgICBmb3IgaG93IGxvbmcgdG8gaGlkZSB0aGUgZWxlbWVudCBhbmQgaXQgY2FuIGNhdXNlIHRoZSBVSSB0byBibGluay5cXG4gIC0tPlxcbiAgPGNpcmNsZVxcbiAgICAqbmdTd2l0Y2hDYXNlPVxcXCJ0cnVlXFxcIlxcbiAgICBjeD1cXFwiNTAlXFxcIlxcbiAgICBjeT1cXFwiNTAlXFxcIlxcbiAgICBbYXR0ci5yXT1cXFwiX2NpcmNsZVJhZGl1c1xcXCJcXG4gICAgW3N0eWxlLmFuaW1hdGlvbi1uYW1lXT1cXFwiJ21hdC1wcm9ncmVzcy1zcGlubmVyLXN0cm9rZS1yb3RhdGUtJyArIGRpYW1ldGVyXFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLWRhc2hvZmZzZXQucHhdPVxcXCJfc3Ryb2tlRGFzaE9mZnNldFxcXCJcXG4gICAgW3N0eWxlLnN0cm9rZS1kYXNoYXJyYXkucHhdPVxcXCJfc3Ryb2tlQ2lyY3VtZmVyZW5jZVxcXCJcXG4gICAgW3N0eWxlLnN0cm9rZS13aWR0aC4lXT1cXFwiX2NpcmNsZVN0cm9rZVdpZHRoXFxcIj48L2NpcmNsZT5cXG5cXG4gIDxjaXJjbGVcXG4gICAgKm5nU3dpdGNoQ2FzZT1cXFwiZmFsc2VcXFwiXFxuICAgIGN4PVxcXCI1MCVcXFwiXFxuICAgIGN5PVxcXCI1MCVcXFwiXFxuICAgIFthdHRyLnJdPVxcXCJfY2lyY2xlUmFkaXVzXFxcIlxcbiAgICBbc3R5bGUuc3Ryb2tlLWRhc2hvZmZzZXQucHhdPVxcXCJfc3Ryb2tlRGFzaE9mZnNldFxcXCJcXG4gICAgW3N0eWxlLnN0cm9rZS1kYXNoYXJyYXkucHhdPVxcXCJfc3Ryb2tlQ2lyY3VtZmVyZW5jZVxcXCJcXG4gICAgW3N0eWxlLnN0cm9rZS13aWR0aC4lXT1cXFwiX2NpcmNsZVN0cm9rZVdpZHRoXFxcIj48L2NpcmNsZT5cXG48L3N2Zz5cXG5cIixcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1wcm9ncmVzcy1zcGlubmVye2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1wcm9ncmVzcy1zcGlubmVyIHN2Z3twb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm06cm90YXRlKC05MGRlZyk7dG9wOjA7bGVmdDowO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyO292ZXJmbG93OnZpc2libGV9Lm1hdC1wcm9ncmVzcy1zcGlubmVyIGNpcmNsZXtmaWxsOnRyYW5zcGFyZW50O3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyO3RyYW5zaXRpb246c3Ryb2tlLWRhc2hvZmZzZXQgMjI1bXMgbGluZWFyfS5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lciBjaXJjbGV7dHJhbnNpdGlvbjpub25lO2FuaW1hdGlvbjpub25lfS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1pbmRldGVybWluYXRlLWFuaW1hdGlvblttb2RlPWluZGV0ZXJtaW5hdGVde2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1saW5lYXItcm90YXRlIDIwMDBtcyBsaW5lYXIgaW5maW5pdGV9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV17dHJhbnNpdGlvbjpub25lO2FuaW1hdGlvbjpub25lfS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1pbmRldGVybWluYXRlLWFuaW1hdGlvblttb2RlPWluZGV0ZXJtaW5hdGVdIGNpcmNsZXt0cmFuc2l0aW9uLXByb3BlcnR5OnN0cm9rZTthbmltYXRpb24tZHVyYXRpb246NDAwMG1zO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuMzUsIDAsIDAuMjUsIDEpO2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6aW5maW5pdGV9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV0gY2lyY2xle3RyYW5zaXRpb246bm9uZTthbmltYXRpb246bm9uZX0ubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1mYWxsYmFjay1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXXthbmltYXRpb246bWF0LXByb2dyZXNzLXNwaW5uZXItc3Ryb2tlLXJvdGF0ZS1mYWxsYmFjayAxMDAwMG1zIGN1YmljLWJlemllcigwLjg3LCAwLjAzLCAwLjMzLCAxKSBpbmZpbml0ZX0uX21hdC1hbmltYXRpb24tbm9vcGFibGUubWF0LXByb2dyZXNzLXNwaW5uZXIubWF0LXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZS1mYWxsYmFjay1hbmltYXRpb25bbW9kZT1pbmRldGVybWluYXRlXXt0cmFuc2l0aW9uOm5vbmU7YW5pbWF0aW9uOm5vbmV9Lm1hdC1wcm9ncmVzcy1zcGlubmVyLm1hdC1wcm9ncmVzcy1zcGlubmVyLWluZGV0ZXJtaW5hdGUtZmFsbGJhY2stYW5pbWF0aW9uW21vZGU9aW5kZXRlcm1pbmF0ZV0gY2lyY2xle3RyYW5zaXRpb24tcHJvcGVydHk6c3Ryb2tlfS5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZS5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1pbmRldGVybWluYXRlLWZhbGxiYWNrLWFuaW1hdGlvblttb2RlPWluZGV0ZXJtaW5hdGVdIGNpcmNsZXt0cmFuc2l0aW9uOm5vbmU7YW5pbWF0aW9uOm5vbmV9QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1saW5lYXItcm90YXRlezAle3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLXNwaW5uZXItc3Ryb2tlLXJvdGF0ZS0xMDB7MCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGUoMCl9MTIuNSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGUoMCl9MTIuNTAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6NTYuNTQ4NjY3N3B4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDcyLjVkZWcpfTI1JXtzdHJva2UtZGFzaG9mZnNldDoyNjguNjA2MTcxNTc1cHg7dHJhbnNmb3JtOnJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoNzIuNWRlZyl9MjUuMDAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX0zNy41JXtzdHJva2UtZGFzaG9mZnNldDo1Ni41NDg2Njc3cHg7dHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpfTM3LjUwMDEle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSgxNjEuNWRlZyl9NTAle3N0cm9rZS1kYXNob2Zmc2V0OjI2OC42MDYxNzE1NzVweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSgxNjEuNWRlZyl9NTAuMDAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX02Mi41JXtzdHJva2UtZGFzaG9mZnNldDo1Ni41NDg2Njc3cHg7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfTYyLjUwMDEle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSgyNTEuNWRlZyl9NzUle3N0cm9rZS1kYXNob2Zmc2V0OjI2OC42MDYxNzE1NzVweDt0cmFuc2Zvcm06cm90YXRlWCgxODBkZWcpIHJvdGF0ZSgyNTEuNWRlZyl9NzUuMDAwMSV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfTg3LjUle3N0cm9rZS1kYXNob2Zmc2V0OjU2LjU0ODY2NzdweDt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX04Ny41MDAxJXtzdHJva2UtZGFzaG9mZnNldDo1Ni41NDg2Njc3cHg7dHJhbnNmb3JtOnJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMzQxLjVkZWcpfTEwMCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjY4LjYwNjE3MTU3NXB4O3RyYW5zZm9ybTpyb3RhdGVYKDE4MGRlZykgcm90YXRlKDM0MS41ZGVnKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHJva2Utcm90YXRlLWZhbGxiYWNrezAle3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9MjUle3RyYW5zZm9ybTpyb3RhdGUoMTE3MGRlZyl9NTAle3RyYW5zZm9ybTpyb3RhdGUoMjM0MGRlZyl9NzUle3RyYW5zZm9ybTpyb3RhdGUoMzUxMGRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDQ2ODBkZWcpfX1cXG5cIl1cbiAgICAgICAgICAgIH1dIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk1hdFNwaW5uZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBQbGF0Zm9ybSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0RPQ1VNRU5ULF0gfV0gfSxcbiAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtBTklNQVRJT05fTU9EVUxFX1RZUEUsXSB9XSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNQVRfUFJPR1JFU1NfU1BJTk5FUl9ERUZBVUxUX09QVElPTlMsXSB9XSB9XG5dO1xuLyoqXG4gKiBHZXRzIHRoZSBzaGFkb3cgcm9vdCBvZiBhbiBlbGVtZW50LCBpZiBzdXBwb3J0ZWQgYW5kIHRoZSBlbGVtZW50IGlzIGluc2lkZSB0aGUgU2hhZG93IERPTS5cbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBfZG9jdW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0U2hhZG93Um9vdChlbGVtZW50LCBfZG9jdW1lbnQpIHtcbiAgICAvLyBUT0RPKGNyaXNiZXRvKTogc2VlIHdoZXRoZXIgd2Ugc2hvdWxkIG1vdmUgdGhpcyBpbnRvIHRoZSBDREtcbiAgICAvLyBmZWF0dXJlIGRldGVjdGlvbiB1dGlsaXRpZXMgb25jZSAjMTU2MTYgZ2V0cyBtZXJnZWQgaW4uXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgaGVhZCA9IF9kb2N1bWVudC5oZWFkO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIFNoYWRvdyBET00uXG4gICAgICAgIGlmIChoZWFkICYmICgoKC8qKiBAdHlwZSB7P30gKi8gKGhlYWQpKSkuY3JlYXRlU2hhZG93Um9vdCB8fCBoZWFkLmF0dGFjaFNoYWRvdykpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZWxlbWVudC5nZXRSb290Tm9kZSA/IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKSA6IG51bGw7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRha2UgdGhlIGBTaGFkb3dSb290YCBvZmYgb2YgYHdpbmRvd2AsIGJlY2F1c2UgdGhlIGJ1aWx0LWluIHR5cGVzIGFyZVxuICAgICAgICAgICAgLy8gaW5jb3JyZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNzkyOS5cbiAgICAgICAgICAgIGlmIChyb290Tm9kZSBpbnN0YW5jZW9mICgoLyoqIEB0eXBlIHs/fSAqLyAod2luZG93KSkpLlNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4iXX0=