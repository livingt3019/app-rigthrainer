/**
 * @fileoverview added by tsickle
 * Generated from: packages/core/src/metadata/directives.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy } from '../change_detection/constants';
import { compileComponent as render3CompileComponent, compileDirective as render3CompileDirective } from '../render3/jit/directive';
import { compilePipe as render3CompilePipe } from '../render3/jit/pipe';
import { makeDecorator, makePropDecorator } from '../util/decorators';
import { noop } from '../util/noop';
/**
 * Type of the Directive decorator / constructor function.
 * \@publicApi
 * @record
 */
export function DirectiveDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ0 = /**
 * @param {?=} dir
 * @return {?}
 */
(dir = {}) => dir, ɵ1 = /**
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_DIRECTIVE(type, meta);
/**
 * Type of the Directive metadata.
 *
 * \@publicApi
 * @type {?}
 */
export const Directive = makeDecorator('Directive', (ɵ0), undefined, undefined, (ɵ1));
/**
 * Component decorator interface
 *
 * \@publicApi
 * @record
 */
export function ComponentDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ2 = /**
 * @param {?=} c
 * @return {?}
 */
(c = {}) => (Object.assign({ changeDetection: ChangeDetectionStrategy.Default }, c)), ɵ3 = /**
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_COMPONENT(type, meta);
/**
 * Component decorator and metadata.
 *
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Component = makeDecorator('Component', (ɵ2), Directive, undefined, (ɵ3));
/**
 * Type of the Pipe decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function PipeDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ4 = /**
 * @param {?} p
 * @return {?}
 */
(p) => (Object.assign({ pure: true }, p)), ɵ5 = /**
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_PIPE(type, meta);
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Pipe = makeDecorator('Pipe', (ɵ4), undefined, undefined, (ɵ5));
/**
 * \@publicApi
 * @record
 */
export function InputDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ6 = /**
 * @param {?=} bindingPropertyName
 * @return {?}
 */
(bindingPropertyName) => ({ bindingPropertyName });
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Input = makePropDecorator('Input', (ɵ6));
/**
 * Type of the Output decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function OutputDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ7 = /**
 * @param {?=} bindingPropertyName
 * @return {?}
 */
(bindingPropertyName) => ({ bindingPropertyName });
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const Output = makePropDecorator('Output', (ɵ7));
/**
 * Type of the HostBinding decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function HostBindingDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ8 = /**
 * @param {?=} hostPropertyName
 * @return {?}
 */
(hostPropertyName) => ({ hostPropertyName });
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const HostBinding = makePropDecorator('HostBinding', (ɵ8));
/**
 * Type of the HostListener decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function HostListenerDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ9 = /**
 * @param {?=} eventName
 * @param {?=} args
 * @return {?}
 */
(eventName, args) => ({ eventName, args });
/**
 * Decorator that binds a DOM event to a host listener and supplies configuration metadata.
 * Angular invokes the supplied handler method when the host element emits the specified event,
 * and updates the bound element with the result.
 *
 * If the handler method returns false, applies `preventDefault` on the bound element.
 *
 * \@usageNotes
 *
 * The following example declares a directive
 * that attaches a click listener to a button and counts clicks.
 *
 * ```ts
 * \@Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 * \@HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
 *  }
 * }
 *
 * \@Component({
 *   selector: 'app',
 *   template: '<button counting>Increment</button>',
 * })
 * class App {}
 *
 * ```
 *
 * The following example registers another DOM event handler that listens for key-press events.
 * ``` ts
 * import { HostListener, Component } from "\@angular/core";
 *
 * \@Component({
 *   selector: 'app',
 *   template: `<h1>Hello, you have pressed keys {{counter}} number of times!</h1> Press any key to
 * increment the counter.
 *   <button (click)="resetCounter()">Reset Counter</button>`
 * })
 * class AppComponent {
 *   counter = 0;
 * \@HostListener('window:keydown', ['$event'])
 *   handleKeyDown(event: KeyboardEvent) {
 *     this.counter++;
 *   }
 *   resetCounter() {
 *     this.counter = 0;
 *   }
 * }
 * ```
 *
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const HostListener = makePropDecorator('HostListener', (ɵ9));
/** @type {?} */
export const SWITCH_COMPILE_COMPONENT__POST_R3__ = render3CompileComponent;
/** @type {?} */
export const SWITCH_COMPILE_DIRECTIVE__POST_R3__ = render3CompileDirective;
/** @type {?} */
export const SWITCH_COMPILE_PIPE__POST_R3__ = render3CompilePipe;
/** @type {?} */
const SWITCH_COMPILE_COMPONENT__PRE_R3__ = noop;
/** @type {?} */
const SWITCH_COMPILE_DIRECTIVE__PRE_R3__ = noop;
/** @type {?} */
const SWITCH_COMPILE_PIPE__PRE_R3__ = noop;
/** @type {?} */
const SWITCH_COMPILE_COMPONENT = SWITCH_COMPILE_COMPONENT__POST_R3__;
/** @type {?} */
const SWITCH_COMPILE_DIRECTIVE = SWITCH_COMPILE_DIRECTIVE__POST_R3__;
/** @type {?} */
const SWITCH_COMPILE_PIPE = SWITCH_COMPILE_PIPE__POST_R3__;
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6, ɵ7, ɵ8, ɵ9 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L2ZpbmFsMy9jdXJzb3Mvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvZXNtMjAxNS9zcmMvbWV0YWRhdGEvZGlyZWN0aXZlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQXVPaUMsbUNBQWtDOztpQ0FFbEMsbUNBQWtDOzs0QkFFdkMsOEJBQTZCIiwiZmlsZSI6ImRpcmVjdGl2ZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogR2VuZXJhdGVkIGZyb206IHBhY2thZ2VzL2NvcmUvc3JjL21ldGFkYXRhL2RpcmVjdGl2ZXMudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi9jaGFuZ2VfZGV0ZWN0aW9uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjb21waWxlQ29tcG9uZW50IGFzIHJlbmRlcjNDb21waWxlQ29tcG9uZW50LCBjb21waWxlRGlyZWN0aXZlIGFzIHJlbmRlcjNDb21waWxlRGlyZWN0aXZlIH0gZnJvbSAnLi4vcmVuZGVyMy9qaXQvZGlyZWN0aXZlJztcbmltcG9ydCB7IGNvbXBpbGVQaXBlIGFzIHJlbmRlcjNDb21waWxlUGlwZSB9IGZyb20gJy4uL3JlbmRlcjMvaml0L3BpcGUnO1xuaW1wb3J0IHsgbWFrZURlY29yYXRvciwgbWFrZVByb3BEZWNvcmF0b3IgfSBmcm9tICcuLi91dGlsL2RlY29yYXRvcnMnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWwvbm9vcCc7XG4vKipcbiAqIFR5cGUgb2YgdGhlIERpcmVjdGl2ZSBkZWNvcmF0b3IgLyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIFxcQHB1YmxpY0FwaVxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gRGlyZWN0aXZlRGVjb3JhdG9yKCkgeyB9XG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XG5jb25zdCDJtTAgPSAvKipcbiAqIEBwYXJhbSB7Pz19IGRpclxuICogQHJldHVybiB7P31cbiAqL1xuKGRpciA9IHt9KSA9PiBkaXIsIMm1MSA9IC8qKlxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcGFyYW0gez99IG1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbih0eXBlLCBtZXRhKSA9PiBTV0lUQ0hfQ09NUElMRV9ESVJFQ1RJVkUodHlwZSwgbWV0YSk7XG4vKipcbiAqIFR5cGUgb2YgdGhlIERpcmVjdGl2ZSBtZXRhZGF0YS5cbiAqXG4gKiBcXEBwdWJsaWNBcGlcbiAqIEB0eXBlIHs/fVxuICovXG5leHBvcnQgY29uc3QgRGlyZWN0aXZlID0gbWFrZURlY29yYXRvcignRGlyZWN0aXZlJywgKMm1MCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAoybUxKSk7XG4vKipcbiAqIENvbXBvbmVudCBkZWNvcmF0b3IgaW50ZXJmYWNlXG4gKlxuICogXFxAcHVibGljQXBpXG4gKiBAcmVjb3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnREZWNvcmF0b3IoKSB7IH1cbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcbmNvbnN0IMm1MiA9IC8qKlxuICogQHBhcmFtIHs/PX0gY1xuICogQHJldHVybiB7P31cbiAqL1xuKGMgPSB7fSkgPT4gKE9iamVjdC5hc3NpZ24oeyBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQgfSwgYykpLCDJtTMgPSAvKipcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHBhcmFtIHs/fSBtZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG4odHlwZSwgbWV0YSkgPT4gU1dJVENIX0NPTVBJTEVfQ09NUE9ORU5UKHR5cGUsIG1ldGEpO1xuLyoqXG4gKiBDb21wb25lbnQgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAqXG4gKiBcXEBBbm5vdGF0aW9uXG4gKiBcXEBwdWJsaWNBcGlcbiAqIEB0eXBlIHs/fVxuICovXG5leHBvcnQgY29uc3QgQ29tcG9uZW50ID0gbWFrZURlY29yYXRvcignQ29tcG9uZW50JywgKMm1MiksIERpcmVjdGl2ZSwgdW5kZWZpbmVkLCAoybUzKSk7XG4vKipcbiAqIFR5cGUgb2YgdGhlIFBpcGUgZGVjb3JhdG9yIC8gY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKlxuICogXFxAcHVibGljQXBpXG4gKiBAcmVjb3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQaXBlRGVjb3JhdG9yKCkgeyB9XG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XG5jb25zdCDJtTQgPSAvKipcbiAqIEBwYXJhbSB7P30gcFxuICogQHJldHVybiB7P31cbiAqL1xuKHApID0+IChPYmplY3QuYXNzaWduKHsgcHVyZTogdHJ1ZSB9LCBwKSksIMm1NSA9IC8qKlxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcGFyYW0gez99IG1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbih0eXBlLCBtZXRhKSA9PiBTV0lUQ0hfQ09NUElMRV9QSVBFKHR5cGUsIG1ldGEpO1xuLyoqXG4gKiBcXEBBbm5vdGF0aW9uXG4gKiBcXEBwdWJsaWNBcGlcbiAqIEB0eXBlIHs/fVxuICovXG5leHBvcnQgY29uc3QgUGlwZSA9IG1ha2VEZWNvcmF0b3IoJ1BpcGUnLCAoybU0KSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsICjJtTUpKTtcbi8qKlxuICogXFxAcHVibGljQXBpXG4gKiBAcmVjb3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBJbnB1dERlY29yYXRvcigpIHsgfVxuLy8gV0FSTklORzogaW50ZXJmYWNlIGhhcyBib3RoIGEgdHlwZSBhbmQgYSB2YWx1ZSwgc2tpcHBpbmcgZW1pdFxuY29uc3QgybU2ID0gLyoqXG4gKiBAcGFyYW0gez89fSBiaW5kaW5nUHJvcGVydHlOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG4oYmluZGluZ1Byb3BlcnR5TmFtZSkgPT4gKHsgYmluZGluZ1Byb3BlcnR5TmFtZSB9KTtcbi8qKlxuICogXFxAQW5ub3RhdGlvblxuICogXFxAcHVibGljQXBpXG4gKiBAdHlwZSB7P31cbiAqL1xuZXhwb3J0IGNvbnN0IElucHV0ID0gbWFrZVByb3BEZWNvcmF0b3IoJ0lucHV0JywgKMm1NikpO1xuLyoqXG4gKiBUeXBlIG9mIHRoZSBPdXRwdXQgZGVjb3JhdG9yIC8gY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKlxuICogXFxAcHVibGljQXBpXG4gKiBAcmVjb3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBPdXRwdXREZWNvcmF0b3IoKSB7IH1cbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcbmNvbnN0IMm1NyA9IC8qKlxuICogQHBhcmFtIHs/PX0gYmluZGluZ1Byb3BlcnR5TmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuKGJpbmRpbmdQcm9wZXJ0eU5hbWUpID0+ICh7IGJpbmRpbmdQcm9wZXJ0eU5hbWUgfSk7XG4vKipcbiAqIFxcQEFubm90YXRpb25cbiAqIFxcQHB1YmxpY0FwaVxuICogQHR5cGUgez99XG4gKi9cbmV4cG9ydCBjb25zdCBPdXRwdXQgPSBtYWtlUHJvcERlY29yYXRvcignT3V0cHV0JywgKMm1NykpO1xuLyoqXG4gKiBUeXBlIG9mIHRoZSBIb3N0QmluZGluZyBkZWNvcmF0b3IgLyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqXG4gKiBcXEBwdWJsaWNBcGlcbiAqIEByZWNvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEhvc3RCaW5kaW5nRGVjb3JhdG9yKCkgeyB9XG4vLyBXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0XG5jb25zdCDJtTggPSAvKipcbiAqIEBwYXJhbSB7Pz19IGhvc3RQcm9wZXJ0eU5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbihob3N0UHJvcGVydHlOYW1lKSA9PiAoeyBob3N0UHJvcGVydHlOYW1lIH0pO1xuLyoqXG4gKiBcXEBBbm5vdGF0aW9uXG4gKiBcXEBwdWJsaWNBcGlcbiAqIEB0eXBlIHs/fVxuICovXG5leHBvcnQgY29uc3QgSG9zdEJpbmRpbmcgPSBtYWtlUHJvcERlY29yYXRvcignSG9zdEJpbmRpbmcnLCAoybU4KSk7XG4vKipcbiAqIFR5cGUgb2YgdGhlIEhvc3RMaXN0ZW5lciBkZWNvcmF0b3IgLyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqXG4gKiBcXEBwdWJsaWNBcGlcbiAqIEByZWNvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEhvc3RMaXN0ZW5lckRlY29yYXRvcigpIHsgfVxuLy8gV0FSTklORzogaW50ZXJmYWNlIGhhcyBib3RoIGEgdHlwZSBhbmQgYSB2YWx1ZSwgc2tpcHBpbmcgZW1pdFxuY29uc3QgybU5ID0gLyoqXG4gKiBAcGFyYW0gez89fSBldmVudE5hbWVcbiAqIEBwYXJhbSB7Pz19IGFyZ3NcbiAqIEByZXR1cm4gez99XG4gKi9cbihldmVudE5hbWUsIGFyZ3MpID0+ICh7IGV2ZW50TmFtZSwgYXJncyB9KTtcbi8qKlxuICogRGVjb3JhdG9yIHRoYXQgYmluZHMgYSBET00gZXZlbnQgdG8gYSBob3N0IGxpc3RlbmVyIGFuZCBzdXBwbGllcyBjb25maWd1cmF0aW9uIG1ldGFkYXRhLlxuICogQW5ndWxhciBpbnZva2VzIHRoZSBzdXBwbGllZCBoYW5kbGVyIG1ldGhvZCB3aGVuIHRoZSBob3N0IGVsZW1lbnQgZW1pdHMgdGhlIHNwZWNpZmllZCBldmVudCxcbiAqIGFuZCB1cGRhdGVzIHRoZSBib3VuZCBlbGVtZW50IHdpdGggdGhlIHJlc3VsdC5cbiAqXG4gKiBJZiB0aGUgaGFuZGxlciBtZXRob2QgcmV0dXJucyBmYWxzZSwgYXBwbGllcyBgcHJldmVudERlZmF1bHRgIG9uIHRoZSBib3VuZCBlbGVtZW50LlxuICpcbiAqIFxcQHVzYWdlTm90ZXNcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVjbGFyZXMgYSBkaXJlY3RpdmVcbiAqIHRoYXQgYXR0YWNoZXMgYSBjbGljayBsaXN0ZW5lciB0byBhIGJ1dHRvbiBhbmQgY291bnRzIGNsaWNrcy5cbiAqXG4gKiBgYGB0c1xuICogXFxARGlyZWN0aXZlKHtzZWxlY3RvcjogJ2J1dHRvbltjb3VudGluZ10nfSlcbiAqIGNsYXNzIENvdW50Q2xpY2tzIHtcbiAqICAgbnVtYmVyT2ZDbGlja3MgPSAwO1xuICpcbiAqIFxcQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudC50YXJnZXQnXSlcbiAqICAgb25DbGljayhidG4pIHtcbiAqICAgICBjb25zb2xlLmxvZygnYnV0dG9uJywgYnRuLCAnbnVtYmVyIG9mIGNsaWNrczonLCB0aGlzLm51bWJlck9mQ2xpY2tzKyspO1xuICogIH1cbiAqIH1cbiAqXG4gKiBcXEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcCcsXG4gKiAgIHRlbXBsYXRlOiAnPGJ1dHRvbiBjb3VudGluZz5JbmNyZW1lbnQ8L2J1dHRvbj4nLFxuICogfSlcbiAqIGNsYXNzIEFwcCB7fVxuICpcbiAqIGBgYFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSByZWdpc3RlcnMgYW5vdGhlciBET00gZXZlbnQgaGFuZGxlciB0aGF0IGxpc3RlbnMgZm9yIGtleS1wcmVzcyBldmVudHMuXG4gKiBgYGAgdHNcbiAqIGltcG9ydCB7IEhvc3RMaXN0ZW5lciwgQ29tcG9uZW50IH0gZnJvbSBcIlxcQGFuZ3VsYXIvY29yZVwiO1xuICpcbiAqIFxcQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcbiAqICAgdGVtcGxhdGU6IGA8aDE+SGVsbG8sIHlvdSBoYXZlIHByZXNzZWQga2V5cyB7e2NvdW50ZXJ9fSBudW1iZXIgb2YgdGltZXMhPC9oMT4gUHJlc3MgYW55IGtleSB0b1xuICogaW5jcmVtZW50IHRoZSBjb3VudGVyLlxuICogICA8YnV0dG9uIChjbGljayk9XCJyZXNldENvdW50ZXIoKVwiPlJlc2V0IENvdW50ZXI8L2J1dHRvbj5gXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgY291bnRlciA9IDA7XG4gKiBcXEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzprZXlkb3duJywgWyckZXZlbnQnXSlcbiAqICAgaGFuZGxlS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICogICAgIHRoaXMuY291bnRlcisrO1xuICogICB9XG4gKiAgIHJlc2V0Q291bnRlcigpIHtcbiAqICAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBcXEBBbm5vdGF0aW9uXG4gKiBcXEBwdWJsaWNBcGlcbiAqIEB0eXBlIHs/fVxuICovXG5leHBvcnQgY29uc3QgSG9zdExpc3RlbmVyID0gbWFrZVByb3BEZWNvcmF0b3IoJ0hvc3RMaXN0ZW5lcicsICjJtTkpKTtcbi8qKiBAdHlwZSB7P30gKi9cbmV4cG9ydCBjb25zdCBTV0lUQ0hfQ09NUElMRV9DT01QT05FTlRfX1BPU1RfUjNfXyA9IHJlbmRlcjNDb21waWxlQ29tcG9uZW50O1xuLyoqIEB0eXBlIHs/fSAqL1xuZXhwb3J0IGNvbnN0IFNXSVRDSF9DT01QSUxFX0RJUkVDVElWRV9fUE9TVF9SM19fID0gcmVuZGVyM0NvbXBpbGVEaXJlY3RpdmU7XG4vKiogQHR5cGUgez99ICovXG5leHBvcnQgY29uc3QgU1dJVENIX0NPTVBJTEVfUElQRV9fUE9TVF9SM19fID0gcmVuZGVyM0NvbXBpbGVQaXBlO1xuLyoqIEB0eXBlIHs/fSAqL1xuY29uc3QgU1dJVENIX0NPTVBJTEVfQ09NUE9ORU5UX19QUkVfUjNfXyA9IG5vb3A7XG4vKiogQHR5cGUgez99ICovXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9ESVJFQ1RJVkVfX1BSRV9SM19fID0gbm9vcDtcbi8qKiBAdHlwZSB7P30gKi9cbmNvbnN0IFNXSVRDSF9DT01QSUxFX1BJUEVfX1BSRV9SM19fID0gbm9vcDtcbi8qKiBAdHlwZSB7P30gKi9cbmNvbnN0IFNXSVRDSF9DT01QSUxFX0NPTVBPTkVOVCA9IFNXSVRDSF9DT01QSUxFX0NPTVBPTkVOVF9fUFJFX1IzX187XG4vKiogQHR5cGUgez99ICovXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9ESVJFQ1RJVkUgPSBTV0lUQ0hfQ09NUElMRV9ESVJFQ1RJVkVfX1BSRV9SM19fO1xuLyoqIEB0eXBlIHs/fSAqL1xuY29uc3QgU1dJVENIX0NPTVBJTEVfUElQRSA9IFNXSVRDSF9DT01QSUxFX1BJUEVfX1BSRV9SM19fO1xuZXhwb3J0IHsgybUwLCDJtTEsIMm1MiwgybUzLCDJtTQsIMm1NSwgybU2LCDJtTcsIMm1OCwgybU5IH07XG4iXX0=