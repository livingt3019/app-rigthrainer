/**
 * @fileoverview added by tsickle
 * Generated from: packages/core/src/metadata/ng_module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ɵɵdefineInjector } from '../di/interface/defs';
import { convertInjectableProviderToFactory } from '../di/util';
import { compileNgModule as render3CompileNgModule } from '../render3/jit/module';
import { makeDecorator } from '../util/decorators';
/**
 * Represents the expansion of an `NgModule` into its scopes.
 *
 * A scope is a set of directives and pipes that are visible in a particular context. Each
 * `NgModule` has two scopes. The `compilation` scope is the set of directives and pipes that will
 * be recognized in the templates of components declared by the module. The `exported` scope is the
 * set of directives and pipes exported by a module (that is, module B's exported scope gets added
 * to module A's compilation scope when module A imports B).
 * @record
 */
export function NgModuleTransitiveScopes() { }
if (false) {
    /** @type {?} */
    NgModuleTransitiveScopes.prototype.compilation;
    /** @type {?} */
    NgModuleTransitiveScopes.prototype.exported;
    /** @type {?} */
    NgModuleTransitiveScopes.prototype.schemas;
}
/**
 * Runtime link information for NgModules.
 *
 * This is the internal data structure used by the runtime to assemble components, directives,
 * pipes, and injectors.
 *
 * NOTE: Always use `ɵɵdefineNgModule` function to create this object,
 * never create the object directly since the shape of this object
 * can change between versions.
 * @record
 * @template T
 */
export function NgModuleDef() { }
if (false) {
    /**
     * Token representing the module. Used by DI.
     * @type {?}
     */
    NgModuleDef.prototype.type;
    /**
     * List of components to bootstrap.
     * @type {?}
     */
    NgModuleDef.prototype.bootstrap;
    /**
     * List of components, directives, and pipes declared by this module.
     * @type {?}
     */
    NgModuleDef.prototype.declarations;
    /**
     * List of modules or `ModuleWithProviders` imported by this module.
     * @type {?}
     */
    NgModuleDef.prototype.imports;
    /**
     * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this
     * module.
     * @type {?}
     */
    NgModuleDef.prototype.exports;
    /**
     * Cached value of computed `transitiveCompileScopes` for this module.
     *
     * This should never be read directly, but accessed via `transitiveScopesFor`.
     * @type {?}
     */
    NgModuleDef.prototype.transitiveCompileScopes;
    /**
     * The set of schemas that declare elements to be allowed in the NgModule.
     * @type {?}
     */
    NgModuleDef.prototype.schemas;
    /**
     * Unique ID for the module with which it should be registered.
     * @type {?}
     */
    NgModuleDef.prototype.id;
}
/**
 * A wrapper around an NgModule that associates it with the providers.
 *
 * @param T the module type. In Ivy applications, this must be explicitly
 * provided.
 *
 * Note that using ModuleWithProviders without a generic type is deprecated.
 * The generic will become required in a future version of Angular.
 *
 * \@publicApi
 * @record
 * @template T
 */
export function ModuleWithProviders() { }
if (false) {
    /** @type {?} */
    ModuleWithProviders.prototype.ngModule;
    /** @type {?|undefined} */
    ModuleWithProviders.prototype.providers;
}
/**
 * Type of the NgModule decorator / constructor function.
 *
 * \@publicApi
 * @record
 */
export function NgModuleDecorator() { }
// WARNING: interface has both a type and a value, skipping emit
const ɵ0 = /**
 * @param {?} ngModule
 * @return {?}
 */
(ngModule) => ngModule, ɵ1 = /**
 * Decorator that marks the following class as an NgModule, and supplies
 * configuration metadata for it.
 *
 * * The `declarations` and `entryComponents` options configure the compiler
 * with information about what belongs to the NgModule.
 * * The `providers` options configures the NgModule's injector to provide
 * dependencies the NgModule members.
 * * The `imports` and `exports` options bring in members from other modules, and make
 * this module's members available to others.
 * @param {?} type
 * @param {?} meta
 * @return {?}
 */
(type, meta) => SWITCH_COMPILE_NGMODULE(type, meta);
/**
 * \@Annotation
 * \@publicApi
 * @type {?}
 */
export const NgModule = makeDecorator('NgModule', (ɵ0), undefined, undefined, (ɵ1));
/**
 * \@description
 * Hook for manual bootstrapping of the application instead of using bootstrap array in \@NgModule
 * annotation.
 *
 * Reference to the current application is provided as a parameter.
 *
 * See ["Bootstrapping"](guide/bootstrapping) and ["Entry components"](guide/entry-components).
 *
 * \@usageNotes
 * ```typescript
 * class AppModule implements DoBootstrap {
 *   ngDoBootstrap(appRef: ApplicationRef) {
 *     appRef.bootstrap(AppComponent); // Or some other component
 *   }
 * }
 * ```
 *
 * \@publicApi
 * @record
 */
export function DoBootstrap() { }
if (false) {
    /**
     * @param {?} appRef
     * @return {?}
     */
    DoBootstrap.prototype.ngDoBootstrap = function (appRef) { };
}
/**
 * @param {?} moduleType
 * @param {?=} metadata
 * @return {?}
 */
function preR3NgModuleCompile(moduleType, metadata) {
    /** @type {?} */
    let imports = (metadata && metadata.imports) || [];
    if (metadata && metadata.exports) {
        imports = [...imports, metadata.exports];
    }
    ((/** @type {?} */ (moduleType))).ɵinj = ɵɵdefineInjector({
        factory: convertInjectableProviderToFactory(moduleType, { useClass: moduleType }),
        providers: metadata && metadata.providers,
        imports: imports,
    });
}
/** @type {?} */
export const SWITCH_COMPILE_NGMODULE__POST_R3__ = render3CompileNgModule;
/** @type {?} */
const SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;
/** @type {?} */
const SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__POST_R3__;
export { ɵ0, ɵ1 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L2ZpbmFsMy9jdXJzb3Mvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvZXNtMjAxNS9zcmMvbWV0YWRhdGEvbmdfbW9kdWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQ0FxTWdDLGtDQUFpQyIsImZpbGUiOiJuZ19tb2R1bGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogR2VuZXJhdGVkIGZyb206IHBhY2thZ2VzL2NvcmUvc3JjL21ldGFkYXRhL25nX21vZHVsZS50c1xuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyDJtcm1ZGVmaW5lSW5qZWN0b3IgfSBmcm9tICcuLi9kaS9pbnRlcmZhY2UvZGVmcyc7XG5pbXBvcnQgeyBjb252ZXJ0SW5qZWN0YWJsZVByb3ZpZGVyVG9GYWN0b3J5IH0gZnJvbSAnLi4vZGkvdXRpbCc7XG5pbXBvcnQgeyBjb21waWxlTmdNb2R1bGUgYXMgcmVuZGVyM0NvbXBpbGVOZ01vZHVsZSB9IGZyb20gJy4uL3JlbmRlcjMvaml0L21vZHVsZSc7XG5pbXBvcnQgeyBtYWtlRGVjb3JhdG9yIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzJztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZXhwYW5zaW9uIG9mIGFuIGBOZ01vZHVsZWAgaW50byBpdHMgc2NvcGVzLlxuICpcbiAqIEEgc2NvcGUgaXMgYSBzZXQgb2YgZGlyZWN0aXZlcyBhbmQgcGlwZXMgdGhhdCBhcmUgdmlzaWJsZSBpbiBhIHBhcnRpY3VsYXIgY29udGV4dC4gRWFjaFxuICogYE5nTW9kdWxlYCBoYXMgdHdvIHNjb3Blcy4gVGhlIGBjb21waWxhdGlvbmAgc2NvcGUgaXMgdGhlIHNldCBvZiBkaXJlY3RpdmVzIGFuZCBwaXBlcyB0aGF0IHdpbGxcbiAqIGJlIHJlY29nbml6ZWQgaW4gdGhlIHRlbXBsYXRlcyBvZiBjb21wb25lbnRzIGRlY2xhcmVkIGJ5IHRoZSBtb2R1bGUuIFRoZSBgZXhwb3J0ZWRgIHNjb3BlIGlzIHRoZVxuICogc2V0IG9mIGRpcmVjdGl2ZXMgYW5kIHBpcGVzIGV4cG9ydGVkIGJ5IGEgbW9kdWxlICh0aGF0IGlzLCBtb2R1bGUgQidzIGV4cG9ydGVkIHNjb3BlIGdldHMgYWRkZWRcbiAqIHRvIG1vZHVsZSBBJ3MgY29tcGlsYXRpb24gc2NvcGUgd2hlbiBtb2R1bGUgQSBpbXBvcnRzIEIpLlxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gTmdNb2R1bGVUcmFuc2l0aXZlU2NvcGVzKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTmdNb2R1bGVUcmFuc2l0aXZlU2NvcGVzLnByb3RvdHlwZS5jb21waWxhdGlvbjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTmdNb2R1bGVUcmFuc2l0aXZlU2NvcGVzLnByb3RvdHlwZS5leHBvcnRlZDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTmdNb2R1bGVUcmFuc2l0aXZlU2NvcGVzLnByb3RvdHlwZS5zY2hlbWFzO1xufVxuLyoqXG4gKiBSdW50aW1lIGxpbmsgaW5mb3JtYXRpb24gZm9yIE5nTW9kdWxlcy5cbiAqXG4gKiBUaGlzIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSB1c2VkIGJ5IHRoZSBydW50aW1lIHRvIGFzc2VtYmxlIGNvbXBvbmVudHMsIGRpcmVjdGl2ZXMsXG4gKiBwaXBlcywgYW5kIGluamVjdG9ycy5cbiAqXG4gKiBOT1RFOiBBbHdheXMgdXNlIGDJtcm1ZGVmaW5lTmdNb2R1bGVgIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGlzIG9iamVjdCxcbiAqIG5ldmVyIGNyZWF0ZSB0aGUgb2JqZWN0IGRpcmVjdGx5IHNpbmNlIHRoZSBzaGFwZSBvZiB0aGlzIG9iamVjdFxuICogY2FuIGNoYW5nZSBiZXR3ZWVuIHZlcnNpb25zLlxuICogQHJlY29yZFxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5nTW9kdWxlRGVmKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBUb2tlbiByZXByZXNlbnRpbmcgdGhlIG1vZHVsZS4gVXNlZCBieSBESS5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ01vZHVsZURlZi5wcm90b3R5cGUudHlwZTtcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGNvbXBvbmVudHMgdG8gYm9vdHN0cmFwLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5ib290c3RyYXA7XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBjb21wb25lbnRzLCBkaXJlY3RpdmVzLCBhbmQgcGlwZXMgZGVjbGFyZWQgYnkgdGhpcyBtb2R1bGUuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTmdNb2R1bGVEZWYucHJvdG90eXBlLmRlY2xhcmF0aW9ucztcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIG1vZHVsZXMgb3IgYE1vZHVsZVdpdGhQcm92aWRlcnNgIGltcG9ydGVkIGJ5IHRoaXMgbW9kdWxlLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5pbXBvcnRzO1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgbW9kdWxlcywgYE1vZHVsZVdpdGhQcm92aWRlcnNgLCBjb21wb25lbnRzLCBkaXJlY3RpdmVzLCBvciBwaXBlcyBleHBvcnRlZCBieSB0aGlzXG4gICAgICogbW9kdWxlLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5leHBvcnRzO1xuICAgIC8qKlxuICAgICAqIENhY2hlZCB2YWx1ZSBvZiBjb21wdXRlZCBgdHJhbnNpdGl2ZUNvbXBpbGVTY29wZXNgIGZvciB0aGlzIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIG5ldmVyIGJlIHJlYWQgZGlyZWN0bHksIGJ1dCBhY2Nlc3NlZCB2aWEgYHRyYW5zaXRpdmVTY29wZXNGb3JgLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS50cmFuc2l0aXZlQ29tcGlsZVNjb3BlcztcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIHNjaGVtYXMgdGhhdCBkZWNsYXJlIGVsZW1lbnRzIHRvIGJlIGFsbG93ZWQgaW4gdGhlIE5nTW9kdWxlLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5zY2hlbWFzO1xuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBJRCBmb3IgdGhlIG1vZHVsZSB3aXRoIHdoaWNoIGl0IHNob3VsZCBiZSByZWdpc3RlcmVkLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlRGVmLnByb3RvdHlwZS5pZDtcbn1cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBOZ01vZHVsZSB0aGF0IGFzc29jaWF0ZXMgaXQgd2l0aCB0aGUgcHJvdmlkZXJzLlxuICpcbiAqIEBwYXJhbSBUIHRoZSBtb2R1bGUgdHlwZS4gSW4gSXZ5IGFwcGxpY2F0aW9ucywgdGhpcyBtdXN0IGJlIGV4cGxpY2l0bHlcbiAqIHByb3ZpZGVkLlxuICpcbiAqIE5vdGUgdGhhdCB1c2luZyBNb2R1bGVXaXRoUHJvdmlkZXJzIHdpdGhvdXQgYSBnZW5lcmljIHR5cGUgaXMgZGVwcmVjYXRlZC5cbiAqIFRoZSBnZW5lcmljIHdpbGwgYmVjb21lIHJlcXVpcmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgQW5ndWxhci5cbiAqXG4gKiBcXEBwdWJsaWNBcGlcbiAqIEByZWNvcmRcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNb2R1bGVXaXRoUHJvdmlkZXJzKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTW9kdWxlV2l0aFByb3ZpZGVycy5wcm90b3R5cGUubmdNb2R1bGU7XG4gICAgLyoqIEB0eXBlIHs/fHVuZGVmaW5lZH0gKi9cbiAgICBNb2R1bGVXaXRoUHJvdmlkZXJzLnByb3RvdHlwZS5wcm92aWRlcnM7XG59XG4vKipcbiAqIFR5cGUgb2YgdGhlIE5nTW9kdWxlIGRlY29yYXRvciAvIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICpcbiAqIFxcQHB1YmxpY0FwaVxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gTmdNb2R1bGVEZWNvcmF0b3IoKSB7IH1cbi8vIFdBUk5JTkc6IGludGVyZmFjZSBoYXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHNraXBwaW5nIGVtaXRcbmNvbnN0IMm1MCA9IC8qKlxuICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICogQHJldHVybiB7P31cbiAqL1xuKG5nTW9kdWxlKSA9PiBuZ01vZHVsZSwgybUxID0gLyoqXG4gKiBEZWNvcmF0b3IgdGhhdCBtYXJrcyB0aGUgZm9sbG93aW5nIGNsYXNzIGFzIGFuIE5nTW9kdWxlLCBhbmQgc3VwcGxpZXNcbiAqIGNvbmZpZ3VyYXRpb24gbWV0YWRhdGEgZm9yIGl0LlxuICpcbiAqICogVGhlIGBkZWNsYXJhdGlvbnNgIGFuZCBgZW50cnlDb21wb25lbnRzYCBvcHRpb25zIGNvbmZpZ3VyZSB0aGUgY29tcGlsZXJcbiAqIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBiZWxvbmdzIHRvIHRoZSBOZ01vZHVsZS5cbiAqICogVGhlIGBwcm92aWRlcnNgIG9wdGlvbnMgY29uZmlndXJlcyB0aGUgTmdNb2R1bGUncyBpbmplY3RvciB0byBwcm92aWRlXG4gKiBkZXBlbmRlbmNpZXMgdGhlIE5nTW9kdWxlIG1lbWJlcnMuXG4gKiAqIFRoZSBgaW1wb3J0c2AgYW5kIGBleHBvcnRzYCBvcHRpb25zIGJyaW5nIGluIG1lbWJlcnMgZnJvbSBvdGhlciBtb2R1bGVzLCBhbmQgbWFrZVxuICogdGhpcyBtb2R1bGUncyBtZW1iZXJzIGF2YWlsYWJsZSB0byBvdGhlcnMuXG4gKiBAcGFyYW0gez99IHR5cGVcbiAqIEBwYXJhbSB7P30gbWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuKHR5cGUsIG1ldGEpID0+IFNXSVRDSF9DT01QSUxFX05HTU9EVUxFKHR5cGUsIG1ldGEpO1xuLyoqXG4gKiBcXEBBbm5vdGF0aW9uXG4gKiBcXEBwdWJsaWNBcGlcbiAqIEB0eXBlIHs/fVxuICovXG5leHBvcnQgY29uc3QgTmdNb2R1bGUgPSBtYWtlRGVjb3JhdG9yKCdOZ01vZHVsZScsICjJtTApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgKMm1MSkpO1xuLyoqXG4gKiBcXEBkZXNjcmlwdGlvblxuICogSG9vayBmb3IgbWFudWFsIGJvb3RzdHJhcHBpbmcgb2YgdGhlIGFwcGxpY2F0aW9uIGluc3RlYWQgb2YgdXNpbmcgYm9vdHN0cmFwIGFycmF5IGluIFxcQE5nTW9kdWxlXG4gKiBhbm5vdGF0aW9uLlxuICpcbiAqIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBhcHBsaWNhdGlvbiBpcyBwcm92aWRlZCBhcyBhIHBhcmFtZXRlci5cbiAqXG4gKiBTZWUgW1wiQm9vdHN0cmFwcGluZ1wiXShndWlkZS9ib290c3RyYXBwaW5nKSBhbmQgW1wiRW50cnkgY29tcG9uZW50c1wiXShndWlkZS9lbnRyeS1jb21wb25lbnRzKS5cbiAqXG4gKiBcXEB1c2FnZU5vdGVzXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBBcHBNb2R1bGUgaW1wbGVtZW50cyBEb0Jvb3RzdHJhcCB7XG4gKiAgIG5nRG9Cb290c3RyYXAoYXBwUmVmOiBBcHBsaWNhdGlvblJlZikge1xuICogICAgIGFwcFJlZi5ib290c3RyYXAoQXBwQ29tcG9uZW50KTsgLy8gT3Igc29tZSBvdGhlciBjb21wb25lbnRcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogXFxAcHVibGljQXBpXG4gKiBAcmVjb3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBEb0Jvb3RzdHJhcCgpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhcHBSZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvQm9vdHN0cmFwLnByb3RvdHlwZS5uZ0RvQm9vdHN0cmFwID0gZnVuY3Rpb24gKGFwcFJlZikgeyB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAqIEBwYXJhbSB7Pz19IG1ldGFkYXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwcmVSM05nTW9kdWxlQ29tcGlsZShtb2R1bGVUeXBlLCBtZXRhZGF0YSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBsZXQgaW1wb3J0cyA9IChtZXRhZGF0YSAmJiBtZXRhZGF0YS5pbXBvcnRzKSB8fCBbXTtcbiAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuZXhwb3J0cykge1xuICAgICAgICBpbXBvcnRzID0gWy4uLmltcG9ydHMsIG1ldGFkYXRhLmV4cG9ydHNdO1xuICAgIH1cbiAgICAoKC8qKiBAdHlwZSB7P30gKi8gKG1vZHVsZVR5cGUpKSkuybVpbmogPSDJtcm1ZGVmaW5lSW5qZWN0b3Ioe1xuICAgICAgICBmYWN0b3J5OiBjb252ZXJ0SW5qZWN0YWJsZVByb3ZpZGVyVG9GYWN0b3J5KG1vZHVsZVR5cGUsIHsgdXNlQ2xhc3M6IG1vZHVsZVR5cGUgfSksXG4gICAgICAgIHByb3ZpZGVyczogbWV0YWRhdGEgJiYgbWV0YWRhdGEucHJvdmlkZXJzLFxuICAgICAgICBpbXBvcnRzOiBpbXBvcnRzLFxuICAgIH0pO1xufVxuLyoqIEB0eXBlIHs/fSAqL1xuZXhwb3J0IGNvbnN0IFNXSVRDSF9DT01QSUxFX05HTU9EVUxFX19QT1NUX1IzX18gPSByZW5kZXIzQ29tcGlsZU5nTW9kdWxlO1xuLyoqIEB0eXBlIHs/fSAqL1xuY29uc3QgU1dJVENIX0NPTVBJTEVfTkdNT0RVTEVfX1BSRV9SM19fID0gcHJlUjNOZ01vZHVsZUNvbXBpbGU7XG4vKiogQHR5cGUgez99ICovXG5jb25zdCBTV0lUQ0hfQ09NUElMRV9OR01PRFVMRSA9IFNXSVRDSF9DT01QSUxFX05HTU9EVUxFX19QUkVfUjNfXztcbmV4cG9ydCB7IMm1MCwgybUxIH07XG4iXX0=