/**
 * @fileoverview added by tsickle
 * Generated from: src/cdk/bidi/directionality.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { EventEmitter, Inject, Injectable, Optional } from '@angular/core';
import { DIR_DOCUMENT } from './dir-document-token';
import * as i0 from "@angular/core";
import * as i1 from "angular_material/src/cdk/bidi/dir-document-token";
/**
 * The directionality (LTR / RTL) context for the application (or a subtree of it).
 * Exposes the current direction and a stream of direction changes.
 */
import * as ɵngcc0 from '@angular/core';
export class Directionality {
    /**
     * @param {?=} _document
     */
    constructor(_document) {
        /**
         * The current 'ltr' or 'rtl' value.
         */
        this.value = 'ltr';
        /**
         * Stream that emits whenever the 'ltr' / 'rtl' state changes.
         */
        this.change = new EventEmitter();
        if (_document) {
            // TODO: handle 'auto' value -
            // We still need to account for dir="auto".
            // It looks like HTMLElemenet.dir is also "auto" when that's set to the attribute,
            // but getComputedStyle return either "ltr" or "rtl". avoiding getComputedStyle for now
            /** @type {?} */
            const bodyDir = _document.body ? _document.body.dir : null;
            /** @type {?} */
            const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
            /** @type {?} */
            const value = bodyDir || htmlDir;
            this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.change.complete();
    }
}
Directionality.ɵfac = function Directionality_Factory(t) { return new (t || Directionality)(ɵngcc0.ɵɵinject(DIR_DOCUMENT, 8)); };
/** @nocollapse */
Directionality.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] }] }
];
/** @nocollapse */ Directionality.ɵprov = i0.ɵɵdefineInjectable({ factory: function Directionality_Factory() { return new Directionality(i0.ɵɵinject(i1.DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Directionality, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DIR_DOCUMENT]
            }] }]; }, null); })();
if (false) {
    /**
     * The current 'ltr' or 'rtl' value.
     * @type {?}
     */
    Directionality.prototype.value;
    /**
     * Stream that emits whenever the 'ltr' / 'rtl' state changes.
     * @type {?}
     */
    Directionality.prototype.change;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L2ZpbmFsMy9jdXJzb3Mvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Nkay9lc20yMDE1L2JpZGkvZGlyZWN0aW9uYWxpdHkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlDQyxnSUFHQzs7Ozs7Ozs7Ozs7Ozs7a0NBS3lOIiwiZmlsZSI6ImRpcmVjdGlvbmFsaXR5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEdlbmVyYXRlZCBmcm9tOiBzcmMvY2RrL2JpZGkvZGlyZWN0aW9uYWxpdHkudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5qZWN0YWJsZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERJUl9ET0NVTUVOVCB9IGZyb20gJy4vZGlyLWRvY3VtZW50LXRva2VuJztcbmltcG9ydCAqIGFzIGkwIGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgKiBhcyBpMSBmcm9tIFwiYW5ndWxhcl9tYXRlcmlhbC9zcmMvY2RrL2JpZGkvZGlyLWRvY3VtZW50LXRva2VuXCI7XG4vKipcbiAqIFRoZSBkaXJlY3Rpb25hbGl0eSAoTFRSIC8gUlRMKSBjb250ZXh0IGZvciB0aGUgYXBwbGljYXRpb24gKG9yIGEgc3VidHJlZSBvZiBpdCkuXG4gKiBFeHBvc2VzIHRoZSBjdXJyZW50IGRpcmVjdGlvbiBhbmQgYSBzdHJlYW0gb2YgZGlyZWN0aW9uIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXJlY3Rpb25hbGl0eSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX2RvY3VtZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2RvY3VtZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCAnbHRyJyBvciAncnRsJyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSAnbHRyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW5ldmVyIHRoZSAnbHRyJyAvICdydGwnIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgaWYgKF9kb2N1bWVudCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlICdhdXRvJyB2YWx1ZSAtXG4gICAgICAgICAgICAvLyBXZSBzdGlsbCBuZWVkIHRvIGFjY291bnQgZm9yIGRpcj1cImF1dG9cIi5cbiAgICAgICAgICAgIC8vIEl0IGxvb2tzIGxpa2UgSFRNTEVsZW1lbmV0LmRpciBpcyBhbHNvIFwiYXV0b1wiIHdoZW4gdGhhdCdzIHNldCB0byB0aGUgYXR0cmlidXRlLFxuICAgICAgICAgICAgLy8gYnV0IGdldENvbXB1dGVkU3R5bGUgcmV0dXJuIGVpdGhlciBcImx0clwiIG9yIFwicnRsXCIuIGF2b2lkaW5nIGdldENvbXB1dGVkU3R5bGUgZm9yIG5vd1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgYm9keURpciA9IF9kb2N1bWVudC5ib2R5ID8gX2RvY3VtZW50LmJvZHkuZGlyIDogbnVsbDtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IGh0bWxEaXIgPSBfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgOiBudWxsO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBib2R5RGlyIHx8IGh0bWxEaXI7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gKHZhbHVlID09PSAnbHRyJyB8fCB2YWx1ZSA9PT0gJ3J0bCcpID8gdmFsdWUgOiAnbHRyJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNoYW5nZS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbkRpcmVjdGlvbmFsaXR5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfSxdIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkRpcmVjdGlvbmFsaXR5LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0RJUl9ET0NVTUVOVCxdIH1dIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi8gRGlyZWN0aW9uYWxpdHkuybVwcm92ID0gaTAuybXJtWRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBEaXJlY3Rpb25hbGl0eV9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IERpcmVjdGlvbmFsaXR5KGkwLsm1ybVpbmplY3QoaTEuRElSX0RPQ1VNRU5ULCA4KSk7IH0sIHRva2VuOiBEaXJlY3Rpb25hbGl0eSwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCAnbHRyJyBvciAncnRsJyB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBEaXJlY3Rpb25hbGl0eS5wcm90b3R5cGUudmFsdWU7XG4gICAgLyoqXG4gICAgICogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbmV2ZXIgdGhlICdsdHInIC8gJ3J0bCcgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBEaXJlY3Rpb25hbGl0eS5wcm90b3R5cGUuY2hhbmdlO1xufVxuIl19