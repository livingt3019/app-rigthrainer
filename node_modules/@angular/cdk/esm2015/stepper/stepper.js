/**
 * @fileoverview added by tsickle
 * Generated from: src/cdk/stepper/stepper.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { FocusKeyManager } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { END, ENTER, hasModifierKey, HOME, SPACE } from '@angular/cdk/keycodes';
import { DOCUMENT } from '@angular/common';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, forwardRef, Inject, InjectionToken, Input, Optional, Output, QueryList, TemplateRef, ViewChild, ViewEncapsulation, } from '@angular/core';
import { of as observableOf, Subject } from 'rxjs';
import { startWith, takeUntil } from 'rxjs/operators';
import { CdkStepHeader } from './step-header';
import { CdkStepLabel } from './step-label';
/**
 * Used to generate unique ID for each stepper component.
 * @type {?}
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/bidi';

function CdkStep_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
const _c0 = ["*"];
let nextId = 0;
/**
 * Change event emitted on selection changes.
 */
export class StepperSelectionEvent {
}
if (false) {
    /**
     * Index of the step now selected.
     * @type {?}
     */
    StepperSelectionEvent.prototype.selectedIndex;
    /**
     * Index of the step previously selected.
     * @type {?}
     */
    StepperSelectionEvent.prototype.previouslySelectedIndex;
    /**
     * The step instance now selected.
     * @type {?}
     */
    StepperSelectionEvent.prototype.selectedStep;
    /**
     * The step instance previously selected.
     * @type {?}
     */
    StepperSelectionEvent.prototype.previouslySelectedStep;
}
/**
 * Enum to represent the different states of the steps.
 * @type {?}
 */
export const STEP_STATE = {
    NUMBER: 'number',
    EDIT: 'edit',
    DONE: 'done',
    ERROR: 'error'
};
/**
 * InjectionToken that can be used to specify the global stepper options.
 * @type {?}
 */
export const STEPPER_GLOBAL_OPTIONS = new InjectionToken('STEPPER_GLOBAL_OPTIONS');
/**
 * InjectionToken that can be used to specify the global stepper options.
 * @deprecated Use `STEPPER_GLOBAL_OPTIONS` instead.
 * \@breaking-change 8.0.0.
 * @type {?}
 */
export const MAT_STEPPER_GLOBAL_OPTIONS = STEPPER_GLOBAL_OPTIONS;
/**
 * Configurable options for stepper.
 * @record
 */
export function StepperOptions() { }
if (false) {
    /**
     * Whether the stepper should display an error state or not.
     * Default behavior is assumed to be false.
     * @type {?|undefined}
     */
    StepperOptions.prototype.showError;
    /**
     * Whether the stepper should display the default indicator type
     * or not.
     * Default behavior is assumed to be true.
     * @type {?|undefined}
     */
    StepperOptions.prototype.displayDefaultIndicatorType;
}
export class CdkStep {
    /**
     * \@breaking-change 8.0.0 remove the `?` after `stepperOptions`
     * @param {?} _stepper
     * @param {?=} stepperOptions
     */
    constructor(_stepper, stepperOptions) {
        this._stepper = _stepper;
        /**
         * Whether user has seen the expanded step content or not.
         */
        this.interacted = false;
        this._editable = true;
        this._optional = false;
        this._completedOverride = null;
        this._customError = null;
        this._stepperOptions = stepperOptions ? stepperOptions : {};
        this._displayDefaultIndicatorType = this._stepperOptions.displayDefaultIndicatorType !== false;
        this._showError = !!this._stepperOptions.showError;
    }
    /**
     * Whether the user can return to this step once it has been marked as completed.
     * @return {?}
     */
    get editable() {
        return this._editable;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set editable(value) {
        this._editable = coerceBooleanProperty(value);
    }
    /**
     * Whether the completion of step is optional.
     * @return {?}
     */
    get optional() {
        return this._optional;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set optional(value) {
        this._optional = coerceBooleanProperty(value);
    }
    /**
     * Whether step is marked as completed.
     * @return {?}
     */
    get completed() {
        return this._completedOverride == null ? this._getDefaultCompleted() : this._completedOverride;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set completed(value) {
        this._completedOverride = coerceBooleanProperty(value);
    }
    /**
     * @private
     * @return {?}
     */
    _getDefaultCompleted() {
        return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
    }
    /**
     * Whether step has an error.
     * @return {?}
     */
    get hasError() {
        return this._customError == null ? this._getDefaultError() : this._customError;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set hasError(value) {
        this._customError = coerceBooleanProperty(value);
    }
    /**
     * @private
     * @return {?}
     */
    _getDefaultError() {
        return this.stepControl && this.stepControl.invalid && this.interacted;
    }
    /**
     * Selects this step component.
     * @return {?}
     */
    select() {
        this._stepper.selected = this;
    }
    /**
     * Resets the step to its initial state. Note that this includes resetting form data.
     * @return {?}
     */
    reset() {
        this.interacted = false;
        if (this._completedOverride != null) {
            this._completedOverride = false;
        }
        if (this._customError != null) {
            this._customError = false;
        }
        if (this.stepControl) {
            this.stepControl.reset();
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        // Since basically all inputs of the MatStep get proxied through the view down to the
        // underlying MatStepHeader, we have to make sure that change detection runs correctly.
        this._stepper._stateChanged();
    }
}
CdkStep.ɵfac = function CdkStep_Factory(t) { return new (t || CdkStep)(ɵngcc0.ɵɵdirectiveInject(forwardRef(( /**
                 * @return {?}
                 */() => CdkStepper))), ɵngcc0.ɵɵdirectiveInject(STEPPER_GLOBAL_OPTIONS, 8)); };
CdkStep.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CdkStep, selectors: [["cdk-step"]], contentQueries: function CdkStep_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkStepLabel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepLabel = _t.first);
    } }, viewQuery: function CdkStep_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(TemplateRef, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);
    } }, inputs: { editable: "editable", optional: "optional", completed: "completed", hasError: "hasError", stepControl: "stepControl", label: "label", errorMessage: "errorMessage", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], state: "state" }, exportAs: ["cdkStep"], features: [ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c0, decls: 1, vars: 0, template: function CdkStep_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, CdkStep_ng_template_0_Template, 1, 0, "ng-template");
    } }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
CdkStep.ctorParameters = () => [
    { type: CdkStepper, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => CdkStepper)),] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [STEPPER_GLOBAL_OPTIONS,] }] }
];
CdkStep.propDecorators = {
    stepLabel: [{ type: ContentChild, args: [CdkStepLabel,] }],
    content: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
    stepControl: [{ type: Input }],
    label: [{ type: Input }],
    errorMessage: [{ type: Input }],
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }],
    state: [{ type: Input }],
    editable: [{ type: Input }],
    optional: [{ type: Input }],
    completed: [{ type: Input }],
    hasError: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkStep, [{
        type: Component,
        args: [{
                selector: 'cdk-step',
                exportAs: 'cdkStep',
                template: '<ng-template><ng-content></ng-content></ng-template>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: CdkStepper, decorators: [{
                type: Inject,
                args: [forwardRef(( /**
                                     * @return {?}
                                     */() => CdkStepper))]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [STEPPER_GLOBAL_OPTIONS]
            }] }]; }, { editable: [{
            type: Input
        }], optional: [{
            type: Input
        }], completed: [{
            type: Input
        }], hasError: [{
            type: Input
        }], stepLabel: [{
            type: ContentChild,
            args: [CdkStepLabel]
        }], content: [{
            type: ViewChild,
            args: [TemplateRef, { static: true }]
        }], stepControl: [{
            type: Input
        }], label: [{
            type: Input
        }], errorMessage: [{
            type: Input
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], ariaLabelledby: [{
            type: Input,
            args: ['aria-labelledby']
        }], state: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    CdkStep.ngAcceptInputType_editable;
    /** @type {?} */
    CdkStep.ngAcceptInputType_hasError;
    /** @type {?} */
    CdkStep.ngAcceptInputType_optional;
    /** @type {?} */
    CdkStep.ngAcceptInputType_completed;
    /**
     * @type {?}
     * @private
     */
    CdkStep.prototype._stepperOptions;
    /** @type {?} */
    CdkStep.prototype._showError;
    /** @type {?} */
    CdkStep.prototype._displayDefaultIndicatorType;
    /**
     * Template for step label if it exists.
     * @type {?}
     */
    CdkStep.prototype.stepLabel;
    /**
     * Template for step content.
     * @type {?}
     */
    CdkStep.prototype.content;
    /**
     * The top level abstract control of the step.
     * @type {?}
     */
    CdkStep.prototype.stepControl;
    /**
     * Whether user has seen the expanded step content or not.
     * @type {?}
     */
    CdkStep.prototype.interacted;
    /**
     * Plain text label of the step.
     * @type {?}
     */
    CdkStep.prototype.label;
    /**
     * Error message to display when there's an error.
     * @type {?}
     */
    CdkStep.prototype.errorMessage;
    /**
     * Aria label for the tab.
     * @type {?}
     */
    CdkStep.prototype.ariaLabel;
    /**
     * Reference to the element that the tab is labelled by.
     * Will be cleared if `aria-label` is set at the same time.
     * @type {?}
     */
    CdkStep.prototype.ariaLabelledby;
    /**
     * State of the step.
     * @type {?}
     */
    CdkStep.prototype.state;
    /**
     * @type {?}
     * @private
     */
    CdkStep.prototype._editable;
    /**
     * @type {?}
     * @private
     */
    CdkStep.prototype._optional;
    /** @type {?} */
    CdkStep.prototype._completedOverride;
    /**
     * @type {?}
     * @private
     */
    CdkStep.prototype._customError;
    /**
     * @type {?}
     * @private
     */
    CdkStep.prototype._stepper;
}
export class CdkStepper {
    /**
     * @param {?} _dir
     * @param {?} _changeDetectorRef
     * @param {?=} _elementRef
     * @param {?=} _document
     */
    constructor(_dir, _changeDetectorRef, _elementRef, _document) {
        this._dir = _dir;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        /**
         * Emits when the component is destroyed.
         */
        this._destroyed = new Subject();
        this._linear = false;
        this._selectedIndex = 0;
        /**
         * Event emitted when the selected step has changed.
         */
        this.selectionChange = new EventEmitter();
        this._orientation = 'horizontal';
        this._groupId = nextId++;
        this._document = _document;
    }
    /**
     * The list of step components that the stepper is holding.
     * @return {?}
     */
    get steps() {
        return this._steps;
    }
    /**
     * Whether the validity of previous steps should be checked or not.
     * @return {?}
     */
    get linear() {
        return this._linear;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set linear(value) {
        this._linear = coerceBooleanProperty(value);
    }
    /**
     * The index of the selected step.
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    set selectedIndex(index) {
        /** @type {?} */
        const newIndex = coerceNumberProperty(index);
        if (this.steps) {
            // Ensure that the index can't be out of bounds.
            if (newIndex < 0 || newIndex > this.steps.length - 1) {
                throw Error('cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.');
            }
            if (this._selectedIndex != newIndex && !this._anyControlsInvalidOrPending(newIndex) &&
                (newIndex >= this._selectedIndex || this.steps.toArray()[newIndex].editable)) {
                this._updateSelectedItemIndex(index);
            }
        }
        else {
            this._selectedIndex = newIndex;
        }
    }
    /**
     * The step that is selected.
     * @return {?}
     */
    get selected() {
        // @breaking-change 8.0.0 Change return type to `CdkStep | undefined`.
        return this.steps ? this.steps.toArray()[this.selectedIndex] : (/** @type {?} */ (undefined));
    }
    /**
     * @param {?} step
     * @return {?}
     */
    set selected(step) {
        this.selectedIndex = this.steps ? this.steps.toArray().indexOf(step) : -1;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Note that while the step headers are content children by default, any components that
        // extend this one might have them as view children. We initialize the keyboard handling in
        // AfterViewInit so we're guaranteed for both view and content children to be defined.
        this._keyManager = new FocusKeyManager(this._stepHeader)
            .withWrap()
            .withVerticalOrientation(this._orientation === 'vertical');
        (this._dir ? ((/** @type {?} */ (this._dir.change))) : observableOf())
            .pipe(startWith(this._layoutDirection()), takeUntil(this._destroyed))
            .subscribe((/**
         * @param {?} direction
         * @return {?}
         */
        direction => this._keyManager.withHorizontalOrientation(direction)));
        this._keyManager.updateActiveItem(this._selectedIndex);
        this.steps.changes.pipe(takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            if (!this.selected) {
                this._selectedIndex = Math.max(this._selectedIndex - 1, 0);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /**
     * Selects and focuses the next step in list.
     * @return {?}
     */
    next() {
        this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1);
    }
    /**
     * Selects and focuses the previous step in list.
     * @return {?}
     */
    previous() {
        this.selectedIndex = Math.max(this._selectedIndex - 1, 0);
    }
    /**
     * Resets the stepper to its initial state. Note that this includes clearing form data.
     * @return {?}
     */
    reset() {
        this._updateSelectedItemIndex(0);
        this.steps.forEach((/**
         * @param {?} step
         * @return {?}
         */
        step => step.reset()));
        this._stateChanged();
    }
    /**
     * Returns a unique id for each step label element.
     * @param {?} i
     * @return {?}
     */
    _getStepLabelId(i) {
        return `cdk-step-label-${this._groupId}-${i}`;
    }
    /**
     * Returns unique id for each step content element.
     * @param {?} i
     * @return {?}
     */
    _getStepContentId(i) {
        return `cdk-step-content-${this._groupId}-${i}`;
    }
    /**
     * Marks the component to be change detected.
     * @return {?}
     */
    _stateChanged() {
        this._changeDetectorRef.markForCheck();
    }
    /**
     * Returns position state of the step with the given index.
     * @param {?} index
     * @return {?}
     */
    _getAnimationDirection(index) {
        /** @type {?} */
        const position = index - this._selectedIndex;
        if (position < 0) {
            return this._layoutDirection() === 'rtl' ? 'next' : 'previous';
        }
        else if (position > 0) {
            return this._layoutDirection() === 'rtl' ? 'previous' : 'next';
        }
        return 'current';
    }
    /**
     * Returns the type of icon to be displayed.
     * @param {?} index
     * @param {?=} state
     * @return {?}
     */
    _getIndicatorType(index, state = STEP_STATE.NUMBER) {
        /** @type {?} */
        const step = this.steps.toArray()[index];
        /** @type {?} */
        const isCurrentStep = this._isCurrentStep(index);
        return step._displayDefaultIndicatorType ? this._getDefaultIndicatorLogic(step, isCurrentStep) :
            this._getGuidelineLogic(step, isCurrentStep, state);
    }
    /**
     * @private
     * @param {?} step
     * @param {?} isCurrentStep
     * @return {?}
     */
    _getDefaultIndicatorLogic(step, isCurrentStep) {
        if (step._showError && step.hasError && !isCurrentStep) {
            return STEP_STATE.ERROR;
        }
        else if (!step.completed || isCurrentStep) {
            return STEP_STATE.NUMBER;
        }
        else {
            return step.editable ? STEP_STATE.EDIT : STEP_STATE.DONE;
        }
    }
    /**
     * @private
     * @param {?} step
     * @param {?} isCurrentStep
     * @param {?=} state
     * @return {?}
     */
    _getGuidelineLogic(step, isCurrentStep, state = STEP_STATE.NUMBER) {
        if (step._showError && step.hasError && !isCurrentStep) {
            return STEP_STATE.ERROR;
        }
        else if (step.completed && !isCurrentStep) {
            return STEP_STATE.DONE;
        }
        else if (step.completed && isCurrentStep) {
            return state;
        }
        else if (step.editable && isCurrentStep) {
            return STEP_STATE.EDIT;
        }
        else {
            return state;
        }
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _isCurrentStep(index) {
        return this._selectedIndex === index;
    }
    /**
     * Returns the index of the currently-focused step header.
     * @return {?}
     */
    _getFocusIndex() {
        return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;
    }
    /**
     * @private
     * @param {?} newIndex
     * @return {?}
     */
    _updateSelectedItemIndex(newIndex) {
        /** @type {?} */
        const stepsArray = this.steps.toArray();
        this.selectionChange.emit({
            selectedIndex: newIndex,
            previouslySelectedIndex: this._selectedIndex,
            selectedStep: stepsArray[newIndex],
            previouslySelectedStep: stepsArray[this._selectedIndex],
        });
        // If focus is inside the stepper, move it to the next header, otherwise it may become
        // lost when the active step content is hidden. We can't be more granular with the check
        // (e.g. checking whether focus is inside the active step), because we don't have a
        // reference to the elements that are rendering out the content.
        this._containsFocus() ? this._keyManager.setActiveItem(newIndex) :
            this._keyManager.updateActiveItem(newIndex);
        this._selectedIndex = newIndex;
        this._stateChanged();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onKeydown(event) {
        /** @type {?} */
        const hasModifier = hasModifierKey(event);
        /** @type {?} */
        const keyCode = event.keyCode;
        /** @type {?} */
        const manager = this._keyManager;
        if (manager.activeItemIndex != null && !hasModifier &&
            (keyCode === SPACE || keyCode === ENTER)) {
            this.selectedIndex = manager.activeItemIndex;
            event.preventDefault();
        }
        else if (keyCode === HOME) {
            manager.setFirstItemActive();
            event.preventDefault();
        }
        else if (keyCode === END) {
            manager.setLastItemActive();
            event.preventDefault();
        }
        else {
            manager.onKeydown(event);
        }
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _anyControlsInvalidOrPending(index) {
        /** @type {?} */
        const steps = this.steps.toArray();
        steps[this._selectedIndex].interacted = true;
        if (this._linear && index >= 0) {
            return steps.slice(0, index).some((/**
             * @param {?} step
             * @return {?}
             */
            step => {
                /** @type {?} */
                const control = step.stepControl;
                /** @type {?} */
                const isIncomplete = control ? (control.invalid || control.pending || !step.interacted) : !step.completed;
                return isIncomplete && !step.optional && !step._completedOverride;
            }));
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    _layoutDirection() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * Checks whether the stepper contains the focused element.
     * @private
     * @return {?}
     */
    _containsFocus() {
        if (!this._document || !this._elementRef) {
            return false;
        }
        /** @type {?} */
        const stepperElement = this._elementRef.nativeElement;
        /** @type {?} */
        const focusedElement = this._document.activeElement;
        return stepperElement === focusedElement || stepperElement.contains(focusedElement);
    }
}
CdkStepper.ɵfac = function CdkStepper_Factory(t) { return new (t || CdkStepper)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
CdkStepper.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CdkStepper, selectors: [["", "cdkStepper", ""]], contentQueries: function CdkStepper_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkStep, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, CdkStepHeader, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._steps = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._stepHeader = _t);
    } }, inputs: { linear: "linear", selectedIndex: "selectedIndex", selected: "selected" }, outputs: { selectionChange: "selectionChange" }, exportAs: ["cdkStepper"] });
/** @nocollapse */
CdkStepper.ctorParameters = () => [
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
CdkStepper.propDecorators = {
    _steps: [{ type: ContentChildren, args: [CdkStep, { descendants: true },] }],
    _stepHeader: [{ type: ContentChildren, args: [CdkStepHeader, { descendants: true },] }],
    linear: [{ type: Input }],
    selectedIndex: [{ type: Input }],
    selected: [{ type: Input }],
    selectionChange: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkStepper, [{
        type: Directive,
        args: [{
                selector: '[cdkStepper]',
                exportAs: 'cdkStepper'
            }]
    }], function () { return [{ type: ɵngcc1.Directionality, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { selectionChange: [{
            type: Output
        }], linear: [{
            type: Input
        }], selectedIndex: [{
            type: Input
        }], selected: [{
            type: Input
        }], _steps: [{
            type: ContentChildren,
            args: [CdkStep, { descendants: true }]
        }], _stepHeader: [{
            type: ContentChildren,
            args: [CdkStepHeader, { descendants: true }]
        }] }); })();
if (false) {
    /** @type {?} */
    CdkStepper.ngAcceptInputType_editable;
    /** @type {?} */
    CdkStepper.ngAcceptInputType_optional;
    /** @type {?} */
    CdkStepper.ngAcceptInputType_completed;
    /** @type {?} */
    CdkStepper.ngAcceptInputType_hasError;
    /** @type {?} */
    CdkStepper.ngAcceptInputType_linear;
    /** @type {?} */
    CdkStepper.ngAcceptInputType_selectedIndex;
    /**
     * Emits when the component is destroyed.
     * @type {?}
     * @protected
     */
    CdkStepper.prototype._destroyed;
    /**
     * Used for managing keyboard focus.
     * @type {?}
     * @private
     */
    CdkStepper.prototype._keyManager;
    /**
     * \@breaking-change 8.0.0 Remove `| undefined` once the `_document`
     * constructor param is required.
     * @type {?}
     * @private
     */
    CdkStepper.prototype._document;
    /**
     * The list of step components that the stepper is holding.
     * @deprecated use `steps` instead
     * \@breaking-change 9.0.0 remove this property
     * @type {?}
     */
    CdkStepper.prototype._steps;
    /**
     * The list of step headers of the steps in the stepper.
     * @deprecated Type to be changed to `QueryList<CdkStepHeader>`.
     * \@breaking-change 8.0.0
     * @type {?}
     */
    CdkStepper.prototype._stepHeader;
    /**
     * @type {?}
     * @private
     */
    CdkStepper.prototype._linear;
    /**
     * @type {?}
     * @private
     */
    CdkStepper.prototype._selectedIndex;
    /**
     * Event emitted when the selected step has changed.
     * @type {?}
     */
    CdkStepper.prototype.selectionChange;
    /**
     * Used to track unique ID for each stepper component.
     * @type {?}
     */
    CdkStepper.prototype._groupId;
    /**
     * @type {?}
     * @protected
     */
    CdkStepper.prototype._orientation;
    /**
     * @type {?}
     * @private
     */
    CdkStepper.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    CdkStepper.prototype._changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    CdkStepper.prototype._elementRef;
}
/**
 * Simplified representation of an "AbstractControl" from \@angular/forms.
 * Used to avoid having to bring in \@angular/forms for a single optional interface.
 * \@docs-private
 * @record
 */
function AbstractControlLike() { }
if (false) {
    /** @type {?} */
    AbstractControlLike.prototype.asyncValidator;
    /** @type {?} */
    AbstractControlLike.prototype.dirty;
    /** @type {?} */
    AbstractControlLike.prototype.disabled;
    /** @type {?} */
    AbstractControlLike.prototype.enabled;
    /** @type {?} */
    AbstractControlLike.prototype.errors;
    /** @type {?} */
    AbstractControlLike.prototype.invalid;
    /** @type {?} */
    AbstractControlLike.prototype.parent;
    /** @type {?} */
    AbstractControlLike.prototype.pending;
    /** @type {?} */
    AbstractControlLike.prototype.pristine;
    /** @type {?} */
    AbstractControlLike.prototype.root;
    /** @type {?} */
    AbstractControlLike.prototype.status;
    /** @type {?} */
    AbstractControlLike.prototype.statusChanges;
    /** @type {?} */
    AbstractControlLike.prototype.touched;
    /** @type {?} */
    AbstractControlLike.prototype.untouched;
    /** @type {?} */
    AbstractControlLike.prototype.updateOn;
    /** @type {?} */
    AbstractControlLike.prototype.valid;
    /** @type {?} */
    AbstractControlLike.prototype.validator;
    /** @type {?} */
    AbstractControlLike.prototype.value;
    /** @type {?} */
    AbstractControlLike.prototype.valueChanges;
    /**
     * @return {?}
     */
    AbstractControlLike.prototype.clearAsyncValidators = function () { };
    /**
     * @return {?}
     */
    AbstractControlLike.prototype.clearValidators = function () { };
    /**
     * @param {?=} opts
     * @return {?}
     */
    AbstractControlLike.prototype.disable = function (opts) { };
    /**
     * @param {?=} opts
     * @return {?}
     */
    AbstractControlLike.prototype.enable = function (opts) { };
    /**
     * @param {?} path
     * @return {?}
     */
    AbstractControlLike.prototype.get = function (path) { };
    /**
     * @param {?} errorCode
     * @param {?=} path
     * @return {?}
     */
    AbstractControlLike.prototype.getError = function (errorCode, path) { };
    /**
     * @param {?} errorCode
     * @param {?=} path
     * @return {?}
     */
    AbstractControlLike.prototype.hasError = function (errorCode, path) { };
    /**
     * @return {?}
     */
    AbstractControlLike.prototype.markAllAsTouched = function () { };
    /**
     * @param {?=} opts
     * @return {?}
     */
    AbstractControlLike.prototype.markAsDirty = function (opts) { };
    /**
     * @param {?=} opts
     * @return {?}
     */
    AbstractControlLike.prototype.markAsPending = function (opts) { };
    /**
     * @param {?=} opts
     * @return {?}
     */
    AbstractControlLike.prototype.markAsPristine = function (opts) { };
    /**
     * @param {?=} opts
     * @return {?}
     */
    AbstractControlLike.prototype.markAsTouched = function (opts) { };
    /**
     * @param {?=} opts
     * @return {?}
     */
    AbstractControlLike.prototype.markAsUntouched = function (opts) { };
    /**
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    AbstractControlLike.prototype.patchValue = function (value, options) { };
    /**
     * @param {?=} value
     * @param {?=} options
     * @return {?}
     */
    AbstractControlLike.prototype.reset = function (value, options) { };
    /**
     * @param {?} newValidator
     * @return {?}
     */
    AbstractControlLike.prototype.setAsyncValidators = function (newValidator) { };
    /**
     * @param {?} errors
     * @param {?=} opts
     * @return {?}
     */
    AbstractControlLike.prototype.setErrors = function (errors, opts) { };
    /**
     * @param {?} parent
     * @return {?}
     */
    AbstractControlLike.prototype.setParent = function (parent) { };
    /**
     * @param {?} newValidator
     * @return {?}
     */
    AbstractControlLike.prototype.setValidators = function (newValidator) { };
    /**
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    AbstractControlLike.prototype.setValue = function (value, options) { };
    /**
     * @param {?=} opts
     * @return {?}
     */
    AbstractControlLike.prototype.updateValueAndValidity = function (opts) { };
    /**
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    AbstractControlLike.prototype.patchValue = function (value, options) { };
    /**
     * @param {?=} formState
     * @param {?=} options
     * @return {?}
     */
    AbstractControlLike.prototype.reset = function (formState, options) { };
    /**
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    AbstractControlLike.prototype.setValue = function (value, options) { };
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L2ZpbmFsMy9jdXJzb3Mvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Nkay9lc20yMDE1L3N0ZXBwZXIvc3RlcHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBK0xDLGdEQVNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXNCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNGJELHlLQU1DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFlQSIsImZpbGUiOiJzdGVwcGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEdlbmVyYXRlZCBmcm9tOiBzcmMvY2RrL3N0ZXBwZXIvc3RlcHBlci50c1xuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IEZvY3VzS2V5TWFuYWdlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5LCBjb2VyY2VOdW1iZXJQcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBFTkQsIEVOVEVSLCBoYXNNb2RpZmllcktleSwgSE9NRSwgU1BBQ0UgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiwgSW5wdXQsIE9wdGlvbmFsLCBPdXRwdXQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCwgVmlld0VuY2Fwc3VsYXRpb24sIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBvZiBhcyBvYnNlcnZhYmxlT2YsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHN0YXJ0V2l0aCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2RrU3RlcEhlYWRlciB9IGZyb20gJy4vc3RlcC1oZWFkZXInO1xuaW1wb3J0IHsgQ2RrU3RlcExhYmVsIH0gZnJvbSAnLi9zdGVwLWxhYmVsJztcbi8qKlxuICogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSUQgZm9yIGVhY2ggc3RlcHBlciBjb21wb25lbnQuXG4gKiBAdHlwZSB7P31cbiAqL1xubGV0IG5leHRJZCA9IDA7XG4vKipcbiAqIENoYW5nZSBldmVudCBlbWl0dGVkIG9uIHNlbGVjdGlvbiBjaGFuZ2VzLlxuICovXG5leHBvcnQgY2xhc3MgU3RlcHBlclNlbGVjdGlvbkV2ZW50IHtcbn1cbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBzdGVwIG5vdyBzZWxlY3RlZC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBTdGVwcGVyU2VsZWN0aW9uRXZlbnQucHJvdG90eXBlLnNlbGVjdGVkSW5kZXg7XG4gICAgLyoqXG4gICAgICogSW5kZXggb2YgdGhlIHN0ZXAgcHJldmlvdXNseSBzZWxlY3RlZC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBTdGVwcGVyU2VsZWN0aW9uRXZlbnQucHJvdG90eXBlLnByZXZpb3VzbHlTZWxlY3RlZEluZGV4O1xuICAgIC8qKlxuICAgICAqIFRoZSBzdGVwIGluc3RhbmNlIG5vdyBzZWxlY3RlZC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBTdGVwcGVyU2VsZWN0aW9uRXZlbnQucHJvdG90eXBlLnNlbGVjdGVkU3RlcDtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RlcCBpbnN0YW5jZSBwcmV2aW91c2x5IHNlbGVjdGVkLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIFN0ZXBwZXJTZWxlY3Rpb25FdmVudC5wcm90b3R5cGUucHJldmlvdXNseVNlbGVjdGVkU3RlcDtcbn1cbi8qKlxuICogRW51bSB0byByZXByZXNlbnQgdGhlIGRpZmZlcmVudCBzdGF0ZXMgb2YgdGhlIHN0ZXBzLlxuICogQHR5cGUgez99XG4gKi9cbmV4cG9ydCBjb25zdCBTVEVQX1NUQVRFID0ge1xuICAgIE5VTUJFUjogJ251bWJlcicsXG4gICAgRURJVDogJ2VkaXQnLFxuICAgIERPTkU6ICdkb25lJyxcbiAgICBFUlJPUjogJ2Vycm9yJ1xufTtcbi8qKlxuICogSW5qZWN0aW9uVG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBnbG9iYWwgc3RlcHBlciBvcHRpb25zLlxuICogQHR5cGUgez99XG4gKi9cbmV4cG9ydCBjb25zdCBTVEVQUEVSX0dMT0JBTF9PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuKCdTVEVQUEVSX0dMT0JBTF9PUFRJT05TJyk7XG4vKipcbiAqIEluamVjdGlvblRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZ2xvYmFsIHN0ZXBwZXIgb3B0aW9ucy5cbiAqIEBkZXByZWNhdGVkIFVzZSBgU1RFUFBFUl9HTE9CQUxfT1BUSU9OU2AgaW5zdGVhZC5cbiAqIFxcQGJyZWFraW5nLWNoYW5nZSA4LjAuMC5cbiAqIEB0eXBlIHs/fVxuICovXG5leHBvcnQgY29uc3QgTUFUX1NURVBQRVJfR0xPQkFMX09QVElPTlMgPSBTVEVQUEVSX0dMT0JBTF9PUFRJT05TO1xuLyoqXG4gKiBDb25maWd1cmFibGUgb3B0aW9ucyBmb3Igc3RlcHBlci5cbiAqIEByZWNvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFN0ZXBwZXJPcHRpb25zKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzdGVwcGVyIHNob3VsZCBkaXNwbGF5IGFuIGVycm9yIHN0YXRlIG9yIG5vdC5cbiAgICAgKiBEZWZhdWx0IGJlaGF2aW9yIGlzIGFzc3VtZWQgdG8gYmUgZmFsc2UuXG4gICAgICogQHR5cGUgez98dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIFN0ZXBwZXJPcHRpb25zLnByb3RvdHlwZS5zaG93RXJyb3I7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc3RlcHBlciBzaG91bGQgZGlzcGxheSB0aGUgZGVmYXVsdCBpbmRpY2F0b3IgdHlwZVxuICAgICAqIG9yIG5vdC5cbiAgICAgKiBEZWZhdWx0IGJlaGF2aW9yIGlzIGFzc3VtZWQgdG8gYmUgdHJ1ZS5cbiAgICAgKiBAdHlwZSB7P3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgU3RlcHBlck9wdGlvbnMucHJvdG90eXBlLmRpc3BsYXlEZWZhdWx0SW5kaWNhdG9yVHlwZTtcbn1cbmV4cG9ydCBjbGFzcyBDZGtTdGVwIHtcbiAgICAvKipcbiAgICAgKiBcXEBicmVha2luZy1jaGFuZ2UgOC4wLjAgcmVtb3ZlIHRoZSBgP2AgYWZ0ZXIgYHN0ZXBwZXJPcHRpb25zYFxuICAgICAqIEBwYXJhbSB7P30gX3N0ZXBwZXJcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwcGVyT3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9zdGVwcGVyLCBzdGVwcGVyT3B0aW9ucykge1xuICAgICAgICB0aGlzLl9zdGVwcGVyID0gX3N0ZXBwZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHVzZXIgaGFzIHNlZW4gdGhlIGV4cGFuZGVkIHN0ZXAgY29udGVudCBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmludGVyYWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZWRpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZWRPdmVycmlkZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1c3RvbUVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RlcHBlck9wdGlvbnMgPSBzdGVwcGVyT3B0aW9ucyA/IHN0ZXBwZXJPcHRpb25zIDoge307XG4gICAgICAgIHRoaXMuX2Rpc3BsYXlEZWZhdWx0SW5kaWNhdG9yVHlwZSA9IHRoaXMuX3N0ZXBwZXJPcHRpb25zLmRpc3BsYXlEZWZhdWx0SW5kaWNhdG9yVHlwZSAhPT0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Nob3dFcnJvciA9ICEhdGhpcy5fc3RlcHBlck9wdGlvbnMuc2hvd0Vycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB1c2VyIGNhbiByZXR1cm4gdG8gdGhpcyBzdGVwIG9uY2UgaXQgaGFzIGJlZW4gbWFya2VkIGFzIGNvbXBsZXRlZC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBlZGl0YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgZWRpdGFibGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZWRpdGFibGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjb21wbGV0aW9uIG9mIHN0ZXAgaXMgb3B0aW9uYWwuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgb3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2V0IG9wdGlvbmFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbmFsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciBzdGVwIGlzIG1hcmtlZCBhcyBjb21wbGV0ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgY29tcGxldGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGVkT3ZlcnJpZGUgPT0gbnVsbCA/IHRoaXMuX2dldERlZmF1bHRDb21wbGV0ZWQoKSA6IHRoaXMuX2NvbXBsZXRlZE92ZXJyaWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgY29tcGxldGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlZE92ZXJyaWRlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9nZXREZWZhdWx0Q29tcGxldGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29udHJvbCA/IHRoaXMuc3RlcENvbnRyb2wudmFsaWQgJiYgdGhpcy5pbnRlcmFjdGVkIDogdGhpcy5pbnRlcmFjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHN0ZXAgaGFzIGFuIGVycm9yLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IGhhc0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tRXJyb3IgPT0gbnVsbCA/IHRoaXMuX2dldERlZmF1bHRFcnJvcigpIDogdGhpcy5fY3VzdG9tRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCBoYXNFcnJvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jdXN0b21FcnJvciA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfZ2V0RGVmYXVsdEVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29udHJvbCAmJiB0aGlzLnN0ZXBDb250cm9sLmludmFsaWQgJiYgdGhpcy5pbnRlcmFjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoaXMgc3RlcCBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuX3N0ZXBwZXIuc2VsZWN0ZWQgPSB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHN0ZXAgdG8gaXRzIGluaXRpYWwgc3RhdGUuIE5vdGUgdGhhdCB0aGlzIGluY2x1ZGVzIHJlc2V0dGluZyBmb3JtIGRhdGEuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZWRPdmVycmlkZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRPdmVycmlkZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXN0b21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXN0b21FcnJvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0ZXBDb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBDb250cm9sLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgLy8gU2luY2UgYmFzaWNhbGx5IGFsbCBpbnB1dHMgb2YgdGhlIE1hdFN0ZXAgZ2V0IHByb3hpZWQgdGhyb3VnaCB0aGUgdmlldyBkb3duIHRvIHRoZVxuICAgICAgICAvLyB1bmRlcmx5aW5nIE1hdFN0ZXBIZWFkZXIsIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgY2hhbmdlIGRldGVjdGlvbiBydW5zIGNvcnJlY3RseS5cbiAgICAgICAgdGhpcy5fc3RlcHBlci5fc3RhdGVDaGFuZ2VkKCk7XG4gICAgfVxufVxuQ2RrU3RlcC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLXN0ZXAnLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnY2RrU3RlcCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctdGVtcGxhdGU+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvbmctdGVtcGxhdGU+JyxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9XSB9XG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5DZGtTdGVwLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ2RrU3RlcHBlciwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbZm9yd2FyZFJlZigoLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAoKSA9PiBDZGtTdGVwcGVyKSksXSB9XSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW1NURVBQRVJfR0xPQkFMX09QVElPTlMsXSB9XSB9XG5dO1xuQ2RrU3RlcC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBzdGVwTGFiZWw6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW0Nka1N0ZXBMYWJlbCxdIH1dLFxuICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW1RlbXBsYXRlUmVmLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV0sXG4gICAgc3RlcENvbnRyb2w6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxhYmVsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBlcnJvck1lc3NhZ2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFyaWFMYWJlbDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbCcsXSB9XSxcbiAgICBhcmlhTGFiZWxsZWRieTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnYXJpYS1sYWJlbGxlZGJ5JyxdIH1dLFxuICAgIHN0YXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBlZGl0YWJsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgb3B0aW9uYWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbXBsZXRlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGFzRXJyb3I6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENka1N0ZXAubmdBY2NlcHRJbnB1dFR5cGVfZWRpdGFibGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENka1N0ZXAubmdBY2NlcHRJbnB1dFR5cGVfaGFzRXJyb3I7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENka1N0ZXAubmdBY2NlcHRJbnB1dFR5cGVfb3B0aW9uYWw7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENka1N0ZXAubmdBY2NlcHRJbnB1dFR5cGVfY29tcGxldGVkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2RrU3RlcC5wcm90b3R5cGUuX3N0ZXBwZXJPcHRpb25zO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDZGtTdGVwLnByb3RvdHlwZS5fc2hvd0Vycm9yO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDZGtTdGVwLnByb3RvdHlwZS5fZGlzcGxheURlZmF1bHRJbmRpY2F0b3JUeXBlO1xuICAgIC8qKlxuICAgICAqIFRlbXBsYXRlIGZvciBzdGVwIGxhYmVsIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBDZGtTdGVwLnByb3RvdHlwZS5zdGVwTGFiZWw7XG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZm9yIHN0ZXAgY29udGVudC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBDZGtTdGVwLnByb3RvdHlwZS5jb250ZW50O1xuICAgIC8qKlxuICAgICAqIFRoZSB0b3AgbGV2ZWwgYWJzdHJhY3QgY29udHJvbCBvZiB0aGUgc3RlcC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBDZGtTdGVwLnByb3RvdHlwZS5zdGVwQ29udHJvbDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHVzZXIgaGFzIHNlZW4gdGhlIGV4cGFuZGVkIHN0ZXAgY29udGVudCBvciBub3QuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgQ2RrU3RlcC5wcm90b3R5cGUuaW50ZXJhY3RlZDtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0IGxhYmVsIG9mIHRoZSBzdGVwLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIENka1N0ZXAucHJvdG90eXBlLmxhYmVsO1xuICAgIC8qKlxuICAgICAqIEVycm9yIG1lc3NhZ2UgdG8gZGlzcGxheSB3aGVuIHRoZXJlJ3MgYW4gZXJyb3IuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgQ2RrU3RlcC5wcm90b3R5cGUuZXJyb3JNZXNzYWdlO1xuICAgIC8qKlxuICAgICAqIEFyaWEgbGFiZWwgZm9yIHRoZSB0YWIuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgQ2RrU3RlcC5wcm90b3R5cGUuYXJpYUxhYmVsO1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0aGF0IHRoZSB0YWIgaXMgbGFiZWxsZWQgYnkuXG4gICAgICogV2lsbCBiZSBjbGVhcmVkIGlmIGBhcmlhLWxhYmVsYCBpcyBzZXQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBDZGtTdGVwLnByb3RvdHlwZS5hcmlhTGFiZWxsZWRieTtcbiAgICAvKipcbiAgICAgKiBTdGF0ZSBvZiB0aGUgc3RlcC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBDZGtTdGVwLnByb3RvdHlwZS5zdGF0ZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENka1N0ZXAucHJvdG90eXBlLl9lZGl0YWJsZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENka1N0ZXAucHJvdG90eXBlLl9vcHRpb25hbDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQ2RrU3RlcC5wcm90b3R5cGUuX2NvbXBsZXRlZE92ZXJyaWRlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2RrU3RlcC5wcm90b3R5cGUuX2N1c3RvbUVycm9yO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2RrU3RlcC5wcm90b3R5cGUuX3N0ZXBwZXI7XG59XG5leHBvcnQgY2xhc3MgQ2RrU3RlcHBlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZGlyXG4gICAgICogQHBhcmFtIHs/fSBfY2hhbmdlRGV0ZWN0b3JSZWZcbiAgICAgKiBAcGFyYW0gez89fSBfZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7Pz19IF9kb2N1bWVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9kaXIsIF9jaGFuZ2VEZXRlY3RvclJlZiwgX2VsZW1lbnRSZWYsIF9kb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX2xpbmVhciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgc3RlcCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgdGhpcy5fZ3JvdXBJZCA9IG5leHRJZCsrO1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2Ygc3RlcCBjb21wb25lbnRzIHRoYXQgdGhlIHN0ZXBwZXIgaXMgaG9sZGluZy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBzdGVwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB2YWxpZGl0eSBvZiBwcmV2aW91cyBzdGVwcyBzaG91bGQgYmUgY2hlY2tlZCBvciBub3QuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgbGluZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZWFyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgbGluZWFyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xpbmVhciA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3RlcC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IGNvZXJjZU51bWJlclByb3BlcnR5KGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuc3RlcHMpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBpbmRleCBjYW4ndCBiZSBvdXQgb2YgYm91bmRzLlxuICAgICAgICAgICAgaWYgKG5ld0luZGV4IDwgMCB8fCBuZXdJbmRleCA+IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdjZGtTdGVwcGVyOiBDYW5ub3QgYXNzaWduIG91dC1vZi1ib3VuZHMgdmFsdWUgdG8gYHNlbGVjdGVkSW5kZXhgLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkSW5kZXggIT0gbmV3SW5kZXggJiYgIXRoaXMuX2FueUNvbnRyb2xzSW52YWxpZE9yUGVuZGluZyhuZXdJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAobmV3SW5kZXggPj0gdGhpcy5fc2VsZWN0ZWRJbmRleCB8fCB0aGlzLnN0ZXBzLnRvQXJyYXkoKVtuZXdJbmRleF0uZWRpdGFibGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWRJdGVtSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IG5ld0luZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzdGVwIHRoYXQgaXMgc2VsZWN0ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIC8vIEBicmVha2luZy1jaGFuZ2UgOC4wLjAgQ2hhbmdlIHJldHVybiB0eXBlIHRvIGBDZGtTdGVwIHwgdW5kZWZpbmVkYC5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMgPyB0aGlzLnN0ZXBzLnRvQXJyYXkoKVt0aGlzLnNlbGVjdGVkSW5kZXhdIDogKC8qKiBAdHlwZSB7P30gKi8gKHVuZGVmaW5lZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0ZXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCBzZWxlY3RlZChzdGVwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuc3RlcHMgPyB0aGlzLnN0ZXBzLnRvQXJyYXkoKS5pbmRleE9mKHN0ZXApIDogLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2hpbGUgdGhlIHN0ZXAgaGVhZGVycyBhcmUgY29udGVudCBjaGlsZHJlbiBieSBkZWZhdWx0LCBhbnkgY29tcG9uZW50cyB0aGF0XG4gICAgICAgIC8vIGV4dGVuZCB0aGlzIG9uZSBtaWdodCBoYXZlIHRoZW0gYXMgdmlldyBjaGlsZHJlbi4gV2UgaW5pdGlhbGl6ZSB0aGUga2V5Ym9hcmQgaGFuZGxpbmcgaW5cbiAgICAgICAgLy8gQWZ0ZXJWaWV3SW5pdCBzbyB3ZSdyZSBndWFyYW50ZWVkIGZvciBib3RoIHZpZXcgYW5kIGNvbnRlbnQgY2hpbGRyZW4gdG8gYmUgZGVmaW5lZC5cbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlciA9IG5ldyBGb2N1c0tleU1hbmFnZXIodGhpcy5fc3RlcEhlYWRlcilcbiAgICAgICAgICAgIC53aXRoV3JhcCgpXG4gICAgICAgICAgICAud2l0aFZlcnRpY2FsT3JpZW50YXRpb24odGhpcy5fb3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpO1xuICAgICAgICAodGhpcy5fZGlyID8gKCgvKiogQHR5cGUgez99ICovICh0aGlzLl9kaXIuY2hhbmdlKSkpIDogb2JzZXJ2YWJsZU9mKCkpXG4gICAgICAgICAgICAucGlwZShzdGFydFdpdGgodGhpcy5fbGF5b3V0RGlyZWN0aW9uKCkpLCB0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZGlyZWN0aW9uID0+IHRoaXMuX2tleU1hbmFnZXIud2l0aEhvcml6b250YWxPcmllbnRhdGlvbihkaXJlY3Rpb24pKSk7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIudXBkYXRlQWN0aXZlSXRlbSh0aGlzLl9zZWxlY3RlZEluZGV4KTtcbiAgICAgICAgdGhpcy5zdGVwcy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSgoLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gTWF0aC5tYXgodGhpcy5fc2VsZWN0ZWRJbmRleCAtIDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGFuZCBmb2N1c2VzIHRoZSBuZXh0IHN0ZXAgaW4gbGlzdC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IE1hdGgubWluKHRoaXMuX3NlbGVjdGVkSW5kZXggKyAxLCB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGFuZCBmb2N1c2VzIHRoZSBwcmV2aW91cyBzdGVwIGluIGxpc3QuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBwcmV2aW91cygpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5tYXgodGhpcy5fc2VsZWN0ZWRJbmRleCAtIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHN0ZXBwZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuIE5vdGUgdGhhdCB0aGlzIGluY2x1ZGVzIGNsZWFyaW5nIGZvcm0gZGF0YS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZEl0ZW1JbmRleCgwKTtcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBzdGVwXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBzdGVwID0+IHN0ZXAucmVzZXQoKSkpO1xuICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBzdGVwIGxhYmVsIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHs/fSBpXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfZ2V0U3RlcExhYmVsSWQoaSkge1xuICAgICAgICByZXR1cm4gYGNkay1zdGVwLWxhYmVsLSR7dGhpcy5fZ3JvdXBJZH0tJHtpfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdW5pcXVlIGlkIGZvciBlYWNoIHN0ZXAgY29udGVudCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7P30gaVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2dldFN0ZXBDb250ZW50SWQoaSkge1xuICAgICAgICByZXR1cm4gYGNkay1zdGVwLWNvbnRlbnQtJHt0aGlzLl9ncm91cElkfS0ke2l9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIGNvbXBvbmVudCB0byBiZSBjaGFuZ2UgZGV0ZWN0ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfc3RhdGVDaGFuZ2VkKCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb3NpdGlvbiBzdGF0ZSBvZiB0aGUgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfZ2V0QW5pbWF0aW9uRGlyZWN0aW9uKGluZGV4KSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpbmRleCAtIHRoaXMuX3NlbGVjdGVkSW5kZXg7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXREaXJlY3Rpb24oKSA9PT0gJ3J0bCcgPyAnbmV4dCcgOiAncHJldmlvdXMnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dERpcmVjdGlvbigpID09PSAncnRsJyA/ICdwcmV2aW91cycgOiAnbmV4dCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdjdXJyZW50JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBpY29uIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/PX0gc3RhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9nZXRJbmRpY2F0b3JUeXBlKGluZGV4LCBzdGF0ZSA9IFNURVBfU1RBVEUuTlVNQkVSKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuc3RlcHMudG9BcnJheSgpW2luZGV4XTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBpc0N1cnJlbnRTdGVwID0gdGhpcy5faXNDdXJyZW50U3RlcChpbmRleCk7XG4gICAgICAgIHJldHVybiBzdGVwLl9kaXNwbGF5RGVmYXVsdEluZGljYXRvclR5cGUgPyB0aGlzLl9nZXREZWZhdWx0SW5kaWNhdG9yTG9naWMoc3RlcCwgaXNDdXJyZW50U3RlcCkgOlxuICAgICAgICAgICAgdGhpcy5fZ2V0R3VpZGVsaW5lTG9naWMoc3RlcCwgaXNDdXJyZW50U3RlcCwgc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gc3RlcFxuICAgICAqIEBwYXJhbSB7P30gaXNDdXJyZW50U3RlcFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2dldERlZmF1bHRJbmRpY2F0b3JMb2dpYyhzdGVwLCBpc0N1cnJlbnRTdGVwKSB7XG4gICAgICAgIGlmIChzdGVwLl9zaG93RXJyb3IgJiYgc3RlcC5oYXNFcnJvciAmJiAhaXNDdXJyZW50U3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIFNURVBfU1RBVEUuRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXN0ZXAuY29tcGxldGVkIHx8IGlzQ3VycmVudFN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBTVEVQX1NUQVRFLk5VTUJFUjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwLmVkaXRhYmxlID8gU1RFUF9TVEFURS5FRElUIDogU1RFUF9TVEFURS5ET05FO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBzdGVwXG4gICAgICogQHBhcmFtIHs/fSBpc0N1cnJlbnRTdGVwXG4gICAgICogQHBhcmFtIHs/PX0gc3RhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9nZXRHdWlkZWxpbmVMb2dpYyhzdGVwLCBpc0N1cnJlbnRTdGVwLCBzdGF0ZSA9IFNURVBfU1RBVEUuTlVNQkVSKSB7XG4gICAgICAgIGlmIChzdGVwLl9zaG93RXJyb3IgJiYgc3RlcC5oYXNFcnJvciAmJiAhaXNDdXJyZW50U3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIFNURVBfU1RBVEUuRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RlcC5jb21wbGV0ZWQgJiYgIWlzQ3VycmVudFN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBTVEVQX1NUQVRFLkRPTkU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RlcC5jb21wbGV0ZWQgJiYgaXNDdXJyZW50U3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0ZXAuZWRpdGFibGUgJiYgaXNDdXJyZW50U3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIFNURVBfU1RBVEUuRURJVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9pc0N1cnJlbnRTdGVwKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZEluZGV4ID09PSBpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseS1mb2N1c2VkIHN0ZXAgaGVhZGVyLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2dldEZvY3VzSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlNYW5hZ2VyID8gdGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXggOiB0aGlzLl9zZWxlY3RlZEluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gbmV3SW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF91cGRhdGVTZWxlY3RlZEl0ZW1JbmRleChuZXdJbmRleCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHN0ZXBzQXJyYXkgPSB0aGlzLnN0ZXBzLnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4OiBuZXdJbmRleCxcbiAgICAgICAgICAgIHByZXZpb3VzbHlTZWxlY3RlZEluZGV4OiB0aGlzLl9zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgc2VsZWN0ZWRTdGVwOiBzdGVwc0FycmF5W25ld0luZGV4XSxcbiAgICAgICAgICAgIHByZXZpb3VzbHlTZWxlY3RlZFN0ZXA6IHN0ZXBzQXJyYXlbdGhpcy5fc2VsZWN0ZWRJbmRleF0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiBmb2N1cyBpcyBpbnNpZGUgdGhlIHN0ZXBwZXIsIG1vdmUgaXQgdG8gdGhlIG5leHQgaGVhZGVyLCBvdGhlcndpc2UgaXQgbWF5IGJlY29tZVxuICAgICAgICAvLyBsb3N0IHdoZW4gdGhlIGFjdGl2ZSBzdGVwIGNvbnRlbnQgaXMgaGlkZGVuLiBXZSBjYW4ndCBiZSBtb3JlIGdyYW51bGFyIHdpdGggdGhlIGNoZWNrXG4gICAgICAgIC8vIChlLmcuIGNoZWNraW5nIHdoZXRoZXIgZm9jdXMgaXMgaW5zaWRlIHRoZSBhY3RpdmUgc3RlcCksIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgICAgIC8vIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudHMgdGhhdCBhcmUgcmVuZGVyaW5nIG91dCB0aGUgY29udGVudC5cbiAgICAgICAgdGhpcy5fY29udGFpbnNGb2N1cygpID8gdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKG5ld0luZGV4KSA6XG4gICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnVwZGF0ZUFjdGl2ZUl0ZW0obmV3SW5kZXgpO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gbmV3SW5kZXg7XG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfb25LZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgaGFzTW9kaWZpZXIgPSBoYXNNb2RpZmllcktleShldmVudCk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgbWFuYWdlciA9IHRoaXMuX2tleU1hbmFnZXI7XG4gICAgICAgIGlmIChtYW5hZ2VyLmFjdGl2ZUl0ZW1JbmRleCAhPSBudWxsICYmICFoYXNNb2RpZmllciAmJlxuICAgICAgICAgICAgKGtleUNvZGUgPT09IFNQQUNFIHx8IGtleUNvZGUgPT09IEVOVEVSKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gbWFuYWdlci5hY3RpdmVJdGVtSW5kZXg7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IEhPTUUpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IEVORCkge1xuICAgICAgICAgICAgbWFuYWdlci5zZXRMYXN0SXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9hbnlDb250cm9sc0ludmFsaWRPclBlbmRpbmcoaW5kZXgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBzdGVwcyA9IHRoaXMuc3RlcHMudG9BcnJheSgpO1xuICAgICAgICBzdGVwc1t0aGlzLl9zZWxlY3RlZEluZGV4XS5pbnRlcmFjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVhciAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcHMuc2xpY2UoMCwgaW5kZXgpLnNvbWUoKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzdGVwXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdGVwID0+IHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgY29uc3QgY29udHJvbCA9IHN0ZXAuc3RlcENvbnRyb2w7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5jb21wbGV0ZSA9IGNvbnRyb2wgPyAoY29udHJvbC5pbnZhbGlkIHx8IGNvbnRyb2wucGVuZGluZyB8fCAhc3RlcC5pbnRlcmFjdGVkKSA6ICFzdGVwLmNvbXBsZXRlZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNJbmNvbXBsZXRlICYmICFzdGVwLm9wdGlvbmFsICYmICFzdGVwLl9jb21wbGV0ZWRPdmVycmlkZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfbGF5b3V0RGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgc3RlcHBlciBjb250YWlucyB0aGUgZm9jdXNlZCBlbGVtZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfY29udGFpbnNGb2N1cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudCB8fCAhdGhpcy5fZWxlbWVudFJlZikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgc3RlcHBlckVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gc3RlcHBlckVsZW1lbnQgPT09IGZvY3VzZWRFbGVtZW50IHx8IHN0ZXBwZXJFbGVtZW50LmNvbnRhaW5zKGZvY3VzZWRFbGVtZW50KTtcbiAgICB9XG59XG5DZGtTdGVwcGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrU3RlcHBlcl0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnY2RrU3RlcHBlcicsXG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ2RrU3RlcHBlci5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERpcmVjdGlvbmFsaXR5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbRE9DVU1FTlQsXSB9XSB9XG5dO1xuQ2RrU3RlcHBlci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBfc3RlcHM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW0Nka1N0ZXAsIHsgZGVzY2VuZGFudHM6IHRydWUgfSxdIH1dLFxuICAgIF9zdGVwSGVhZGVyOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtDZGtTdGVwSGVhZGVyLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0sXSB9XSxcbiAgICBsaW5lYXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkSW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Rpb25DaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XVxufTtcbmlmIChmYWxzZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDZGtTdGVwcGVyLm5nQWNjZXB0SW5wdXRUeXBlX2VkaXRhYmxlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDZGtTdGVwcGVyLm5nQWNjZXB0SW5wdXRUeXBlX29wdGlvbmFsO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBDZGtTdGVwcGVyLm5nQWNjZXB0SW5wdXRUeXBlX2NvbXBsZXRlZDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQ2RrU3RlcHBlci5uZ0FjY2VwdElucHV0VHlwZV9oYXNFcnJvcjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQ2RrU3RlcHBlci5uZ0FjY2VwdElucHV0VHlwZV9saW5lYXI7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIENka1N0ZXBwZXIubmdBY2NlcHRJbnB1dFR5cGVfc2VsZWN0ZWRJbmRleDtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBDZGtTdGVwcGVyLnByb3RvdHlwZS5fZGVzdHJveWVkO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIG1hbmFnaW5nIGtleWJvYXJkIGZvY3VzLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2RrU3RlcHBlci5wcm90b3R5cGUuX2tleU1hbmFnZXI7XG4gICAgLyoqXG4gICAgICogXFxAYnJlYWtpbmctY2hhbmdlIDguMC4wIFJlbW92ZSBgfCB1bmRlZmluZWRgIG9uY2UgdGhlIGBfZG9jdW1lbnRgXG4gICAgICogY29uc3RydWN0b3IgcGFyYW0gaXMgcmVxdWlyZWQuXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDZGtTdGVwcGVyLnByb3RvdHlwZS5fZG9jdW1lbnQ7XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2Ygc3RlcCBjb21wb25lbnRzIHRoYXQgdGhlIHN0ZXBwZXIgaXMgaG9sZGluZy5cbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYHN0ZXBzYCBpbnN0ZWFkXG4gICAgICogXFxAYnJlYWtpbmctY2hhbmdlIDkuMC4wIHJlbW92ZSB0aGlzIHByb3BlcnR5XG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgQ2RrU3RlcHBlci5wcm90b3R5cGUuX3N0ZXBzO1xuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIHN0ZXAgaGVhZGVycyBvZiB0aGUgc3RlcHMgaW4gdGhlIHN0ZXBwZXIuXG4gICAgICogQGRlcHJlY2F0ZWQgVHlwZSB0byBiZSBjaGFuZ2VkIHRvIGBRdWVyeUxpc3Q8Q2RrU3RlcEhlYWRlcj5gLlxuICAgICAqIFxcQGJyZWFraW5nLWNoYW5nZSA4LjAuMFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIENka1N0ZXBwZXIucHJvdG90eXBlLl9zdGVwSGVhZGVyO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2RrU3RlcHBlci5wcm90b3R5cGUuX2xpbmVhcjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENka1N0ZXBwZXIucHJvdG90eXBlLl9zZWxlY3RlZEluZGV4O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgc3RlcCBoYXMgY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBDZGtTdGVwcGVyLnByb3RvdHlwZS5zZWxlY3Rpb25DaGFuZ2U7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byB0cmFjayB1bmlxdWUgSUQgZm9yIGVhY2ggc3RlcHBlciBjb21wb25lbnQuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgQ2RrU3RlcHBlci5wcm90b3R5cGUuX2dyb3VwSWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIENka1N0ZXBwZXIucHJvdG90eXBlLl9vcmllbnRhdGlvbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENka1N0ZXBwZXIucHJvdG90eXBlLl9kaXI7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDZGtTdGVwcGVyLnByb3RvdHlwZS5fY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDZGtTdGVwcGVyLnByb3RvdHlwZS5fZWxlbWVudFJlZjtcbn1cbi8qKlxuICogU2ltcGxpZmllZCByZXByZXNlbnRhdGlvbiBvZiBhbiBcIkFic3RyYWN0Q29udHJvbFwiIGZyb20gXFxAYW5ndWxhci9mb3Jtcy5cbiAqIFVzZWQgdG8gYXZvaWQgaGF2aW5nIHRvIGJyaW5nIGluIFxcQGFuZ3VsYXIvZm9ybXMgZm9yIGEgc2luZ2xlIG9wdGlvbmFsIGludGVyZmFjZS5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHJlY29yZFxuICovXG5mdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xMaWtlKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUuYXN5bmNWYWxpZGF0b3I7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLmRpcnR5O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5kaXNhYmxlZDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUuZW5hYmxlZDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUuZXJyb3JzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5pbnZhbGlkO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5wYXJlbnQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnBlbmRpbmc7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnByaXN0aW5lO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5yb290O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5zdGF0dXM7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnN0YXR1c0NoYW5nZXM7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnRvdWNoZWQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnVudG91Y2hlZDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUudXBkYXRlT247XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnZhbGlkO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS52YWxpZGF0b3I7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnZhbHVlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS52YWx1ZUNoYW5nZXM7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5jbGVhckFzeW5jVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLmNsZWFyVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBvcHRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKG9wdHMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBvcHRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAob3B0cykgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yQ29kZVxuICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGF0aCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JDb2RlXG4gICAgICogQHBhcmFtIHs/PX0gcGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUuaGFzRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5tYXJrQWxsQXNUb3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG9wdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLm1hcmtBc0RpcnR5ID0gZnVuY3Rpb24gKG9wdHMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBvcHRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5tYXJrQXNQZW5kaW5nID0gZnVuY3Rpb24gKG9wdHMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBvcHRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5tYXJrQXNQcmlzdGluZSA9IGZ1bmN0aW9uIChvcHRzKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gb3B0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUubWFya0FzVG91Y2hlZCA9IGZ1bmN0aW9uIChvcHRzKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gb3B0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUubWFya0FzVW50b3VjaGVkID0gZnVuY3Rpb24gKG9wdHMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUucGF0Y2hWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5ld1ZhbGlkYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUuc2V0QXN5bmNWYWxpZGF0b3JzID0gZnVuY3Rpb24gKG5ld1ZhbGlkYXRvcikgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHBhcmFtIHs/PX0gb3B0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUuc2V0RXJyb3JzID0gZnVuY3Rpb24gKGVycm9ycywgb3B0cykgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuZXdWYWxpZGF0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnNldFZhbGlkYXRvcnMgPSBmdW5jdGlvbiAobmV3VmFsaWRhdG9yKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gb3B0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSA9IGZ1bmN0aW9uIChvcHRzKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0Q29udHJvbExpa2UucHJvdG90eXBlLnBhdGNoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBmb3JtU3RhdGVcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdENvbnRyb2xMaWtlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChmb3JtU3RhdGUsIG9wdGlvbnMpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RDb250cm9sTGlrZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHsgfTtcbn1cbiJdfQ==