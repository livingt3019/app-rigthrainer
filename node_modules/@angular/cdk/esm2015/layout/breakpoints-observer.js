/**
 * @fileoverview added by tsickle
 * Generated from: src/cdk/layout/breakpoints-observer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injectable, NgZone } from '@angular/core';
import { MediaMatcher } from './media-matcher';
import { combineLatest, concat, Observable, Subject } from 'rxjs';
import { debounceTime, map, skip, startWith, take, takeUntil } from 'rxjs/operators';
import { coerceArray } from '@angular/cdk/coercion';
import * as i0 from "@angular/core";
import * as i1 from "angular_material/src/cdk/layout/media-matcher";
/**
 * The current state of a layout breakpoint.
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function BreakpointState() { }
if (false) {
    /**
     * Whether the breakpoint is currently matching.
     * @type {?}
     */
    BreakpointState.prototype.matches;
    /**
     * A key boolean pair for each query provided to the observe method,
     * with its current matched state.
     * @type {?}
     */
    BreakpointState.prototype.breakpoints;
}
/**
 * The current state of a layout breakpoint.
 * @record
 */
function InternalBreakpointState() { }
if (false) {
    /**
     * Whether the breakpoint is currently matching.
     * @type {?}
     */
    InternalBreakpointState.prototype.matches;
    /**
     * The media query being to be matched
     * @type {?}
     */
    InternalBreakpointState.prototype.query;
}
/**
 * @record
 */
function Query() { }
if (false) {
    /** @type {?} */
    Query.prototype.observable;
    /** @type {?} */
    Query.prototype.mql;
}
/**
 * Utility for checking the matching state of \@media queries.
 */
export class BreakpointObserver {
    /**
     * @param {?} _mediaMatcher
     * @param {?} _zone
     */
    constructor(_mediaMatcher, _zone) {
        this._mediaMatcher = _mediaMatcher;
        this._zone = _zone;
        /**
         * A map of all media queries currently being listened for.
         */
        this._queries = new Map();
        /**
         * A subject for all other observables to takeUntil based on.
         */
        this._destroySubject = new Subject();
    }
    /**
     * Completes the active subject, signalling to all other observables to complete.
     * @return {?}
     */
    ngOnDestroy() {
        this._destroySubject.next();
        this._destroySubject.complete();
    }
    /**
     * Whether one or more media queries match the current viewport size.
     * @param {?} value One or more media queries to check.
     * @return {?} Whether any of the media queries match.
     */
    isMatched(value) {
        /** @type {?} */
        const queries = splitQueries(coerceArray(value));
        return queries.some((/**
         * @param {?} mediaQuery
         * @return {?}
         */
        mediaQuery => this._registerQuery(mediaQuery).mql.matches));
    }
    /**
     * Gets an observable of results for the given queries that will emit new results for any changes
     * in matching of the given queries.
     * @param {?} value One or more media queries to check.
     * @return {?} A stream of matches for the given queries.
     */
    observe(value) {
        /** @type {?} */
        const queries = splitQueries(coerceArray(value));
        /** @type {?} */
        const observables = queries.map((/**
         * @param {?} query
         * @return {?}
         */
        query => this._registerQuery(query).observable));
        /** @type {?} */
        let stateObservable = combineLatest(observables);
        // Emit the first state immediately, and then debounce the subsequent emissions.
        stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
        return stateObservable.pipe(map((/**
         * @param {?} breakpointStates
         * @return {?}
         */
        (breakpointStates) => {
            /** @type {?} */
            const response = {
                matches: false,
                breakpoints: {},
            };
            breakpointStates.forEach((/**
             * @param {?} state
             * @return {?}
             */
            (state) => {
                response.matches = response.matches || state.matches;
                response.breakpoints[state.query] = state.matches;
            }));
            return response;
        })));
    }
    /**
     * Registers a specific query to be listened for.
     * @private
     * @param {?} query
     * @return {?}
     */
    _registerQuery(query) {
        // Only set up a new MediaQueryList if it is not already being listened for.
        if (this._queries.has(query)) {
            return (/** @type {?} */ (this._queries.get(query)));
        }
        /** @type {?} */
        const mql = this._mediaMatcher.matchMedia(query);
        // Create callback for match changes and add it is as a listener.
        /** @type {?} */
        const queryObservable = new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed
            // back into the zone because matchMedia is only included in Zone.js by loading the
            // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not
            // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js
            // patches it.
            /** @type {?} */
            const handler = (/**
             * @param {?} e
             * @return {?}
             */
            (e) => this._zone.run((/**
             * @return {?}
             */
            () => observer.next(e))));
            mql.addListener(handler);
            return (/**
             * @return {?}
             */
            () => {
                mql.removeListener(handler);
            });
        })).pipe(startWith(mql), map((/**
         * @param {?} nextMql
         * @return {?}
         */
        (nextMql) => ({ query, matches: nextMql.matches }))), takeUntil(this._destroySubject));
        // Add the MediaQueryList to the set of queries.
        /** @type {?} */
        const output = { observable: queryObservable, mql };
        this._queries.set(query, output);
        return output;
    }
}
BreakpointObserver.ɵfac = function BreakpointObserver_Factory(t) { return new (t || BreakpointObserver)(ɵngcc0.ɵɵinject(MediaMatcher), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
/** @nocollapse */
BreakpointObserver.ctorParameters = () => [
    { type: MediaMatcher },
    { type: NgZone }
];
/** @nocollapse */ BreakpointObserver.ɵprov = i0.ɵɵdefineInjectable({ factory: function BreakpointObserver_Factory() { return new BreakpointObserver(i0.ɵɵinject(i1.MediaMatcher), i0.ɵɵinject(i0.NgZone)); }, token: BreakpointObserver, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BreakpointObserver, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: MediaMatcher }, { type: ɵngcc0.NgZone }]; }, null); })();
if (false) {
    /**
     * A map of all media queries currently being listened for.
     * @type {?}
     * @private
     */
    BreakpointObserver.prototype._queries;
    /**
     * A subject for all other observables to takeUntil based on.
     * @type {?}
     * @private
     */
    BreakpointObserver.prototype._destroySubject;
    /**
     * @type {?}
     * @private
     */
    BreakpointObserver.prototype._mediaMatcher;
    /**
     * @type {?}
     * @private
     */
    BreakpointObserver.prototype._zone;
}
/**
 * Split each query string into separate query strings if two queries are provided as comma
 * separated.
 * @param {?} queries
 * @return {?}
 */
function splitQueries(queries) {
    return queries.map((/**
     * @param {?} query
     * @return {?}
     */
    (query) => query.split(',')))
        .reduce((/**
     * @param {?} a1
     * @param {?} a2
     * @return {?}
     */
    (a1, a2) => a1.concat(a2)))
        .map((/**
     * @param {?} query
     * @return {?}
     */
    query => query.trim()));
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L2ZpbmFsMy9jdXJzb3Mvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Nkay9lc20yMDE1L2xheW91dC9icmVha3BvaW50cy1vYnNlcnZlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStLQyx5S0FHQzs7Ozs7Ozs7OzsrRkFNOFAiLCJmaWxlIjoiYnJlYWtwb2ludHMtb2JzZXJ2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogR2VuZXJhdGVkIGZyb206IHNyYy9jZGsvbGF5b3V0L2JyZWFrcG9pbnRzLW9ic2VydmVyLnRzXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNZWRpYU1hdGNoZXIgfSBmcm9tICcuL21lZGlhLW1hdGNoZXInO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCwgY29uY2F0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIG1hcCwgc2tpcCwgc3RhcnRXaXRoLCB0YWtlLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBjb2VyY2VBcnJheSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgKiBhcyBpMCBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0ICogYXMgaTEgZnJvbSBcImFuZ3VsYXJfbWF0ZXJpYWwvc3JjL2Nkay9sYXlvdXQvbWVkaWEtbWF0Y2hlclwiO1xuLyoqXG4gKiBUaGUgY3VycmVudCBzdGF0ZSBvZiBhIGxheW91dCBicmVha3BvaW50LlxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gQnJlYWtwb2ludFN0YXRlKCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBicmVha3BvaW50IGlzIGN1cnJlbnRseSBtYXRjaGluZy5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBCcmVha3BvaW50U3RhdGUucHJvdG90eXBlLm1hdGNoZXM7XG4gICAgLyoqXG4gICAgICogQSBrZXkgYm9vbGVhbiBwYWlyIGZvciBlYWNoIHF1ZXJ5IHByb3ZpZGVkIHRvIHRoZSBvYnNlcnZlIG1ldGhvZCxcbiAgICAgKiB3aXRoIGl0cyBjdXJyZW50IG1hdGNoZWQgc3RhdGUuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgQnJlYWtwb2ludFN0YXRlLnByb3RvdHlwZS5icmVha3BvaW50cztcbn1cbi8qKlxuICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgYSBsYXlvdXQgYnJlYWtwb2ludC5cbiAqIEByZWNvcmRcbiAqL1xuZnVuY3Rpb24gSW50ZXJuYWxCcmVha3BvaW50U3RhdGUoKSB7IH1cbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyZWFrcG9pbnQgaXMgY3VycmVudGx5IG1hdGNoaW5nLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIEludGVybmFsQnJlYWtwb2ludFN0YXRlLnByb3RvdHlwZS5tYXRjaGVzO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBxdWVyeSBiZWluZyB0byBiZSBtYXRjaGVkXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgSW50ZXJuYWxCcmVha3BvaW50U3RhdGUucHJvdG90eXBlLnF1ZXJ5O1xufVxuLyoqXG4gKiBAcmVjb3JkXG4gKi9cbmZ1bmN0aW9uIFF1ZXJ5KCkgeyB9XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgUXVlcnkucHJvdG90eXBlLm9ic2VydmFibGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5tcWw7XG59XG4vKipcbiAqIFV0aWxpdHkgZm9yIGNoZWNraW5nIHRoZSBtYXRjaGluZyBzdGF0ZSBvZiBcXEBtZWRpYSBxdWVyaWVzLlxuICovXG5leHBvcnQgY2xhc3MgQnJlYWtwb2ludE9ic2VydmVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9tZWRpYU1hdGNoZXJcbiAgICAgKiBAcGFyYW0gez99IF96b25lXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX21lZGlhTWF0Y2hlciwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFNYXRjaGVyID0gX21lZGlhTWF0Y2hlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgYWxsIG1lZGlhIHF1ZXJpZXMgY3VycmVudGx5IGJlaW5nIGxpc3RlbmVkIGZvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3F1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN1YmplY3QgZm9yIGFsbCBvdGhlciBvYnNlcnZhYmxlcyB0byB0YWtlVW50aWwgYmFzZWQgb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kZXN0cm95U3ViamVjdCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlcyB0aGUgYWN0aXZlIHN1YmplY3QsIHNpZ25hbGxpbmcgdG8gYWxsIG90aGVyIG9ic2VydmFibGVzIHRvIGNvbXBsZXRlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lTdWJqZWN0Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveVN1YmplY3QuY29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciBvbmUgb3IgbW9yZSBtZWRpYSBxdWVyaWVzIG1hdGNoIHRoZSBjdXJyZW50IHZpZXdwb3J0IHNpemUuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZSBPbmUgb3IgbW9yZSBtZWRpYSBxdWVyaWVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4gez99IFdoZXRoZXIgYW55IG9mIHRoZSBtZWRpYSBxdWVyaWVzIG1hdGNoLlxuICAgICAqL1xuICAgIGlzTWF0Y2hlZCh2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBzcGxpdFF1ZXJpZXMoY29lcmNlQXJyYXkodmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJpZXMuc29tZSgoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbWVkaWFRdWVyeVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgbWVkaWFRdWVyeSA9PiB0aGlzLl9yZWdpc3RlclF1ZXJ5KG1lZGlhUXVlcnkpLm1xbC5tYXRjaGVzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gb2JzZXJ2YWJsZSBvZiByZXN1bHRzIGZvciB0aGUgZ2l2ZW4gcXVlcmllcyB0aGF0IHdpbGwgZW1pdCBuZXcgcmVzdWx0cyBmb3IgYW55IGNoYW5nZXNcbiAgICAgKiBpbiBtYXRjaGluZyBvZiB0aGUgZ2l2ZW4gcXVlcmllcy5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlIE9uZSBvciBtb3JlIG1lZGlhIHF1ZXJpZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7P30gQSBzdHJlYW0gb2YgbWF0Y2hlcyBmb3IgdGhlIGdpdmVuIHF1ZXJpZXMuXG4gICAgICovXG4gICAgb2JzZXJ2ZSh2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBzcGxpdFF1ZXJpZXMoY29lcmNlQXJyYXkodmFsdWUpKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBvYnNlcnZhYmxlcyA9IHF1ZXJpZXMubWFwKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBxdWVyeVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgcXVlcnkgPT4gdGhpcy5fcmVnaXN0ZXJRdWVyeShxdWVyeSkub2JzZXJ2YWJsZSkpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGxldCBzdGF0ZU9ic2VydmFibGUgPSBjb21iaW5lTGF0ZXN0KG9ic2VydmFibGVzKTtcbiAgICAgICAgLy8gRW1pdCB0aGUgZmlyc3Qgc3RhdGUgaW1tZWRpYXRlbHksIGFuZCB0aGVuIGRlYm91bmNlIHRoZSBzdWJzZXF1ZW50IGVtaXNzaW9ucy5cbiAgICAgICAgc3RhdGVPYnNlcnZhYmxlID0gY29uY2F0KHN0YXRlT2JzZXJ2YWJsZS5waXBlKHRha2UoMSkpLCBzdGF0ZU9ic2VydmFibGUucGlwZShza2lwKDEpLCBkZWJvdW5jZVRpbWUoMCkpKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlT2JzZXJ2YWJsZS5waXBlKG1hcCgoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gYnJlYWtwb2ludFN0YXRlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgKGJyZWFrcG9pbnRTdGF0ZXMpID0+IHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIG1hdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVha3BvaW50U3RhdGVzLmZvckVhY2goKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzdGF0ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UubWF0Y2hlcyA9IHJlc3BvbnNlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlcztcbiAgICAgICAgICAgICAgICByZXNwb25zZS5icmVha3BvaW50c1tzdGF0ZS5xdWVyeV0gPSBzdGF0ZS5tYXRjaGVzO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBzcGVjaWZpYyBxdWVyeSB0byBiZSBsaXN0ZW5lZCBmb3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHF1ZXJ5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJRdWVyeShxdWVyeSkge1xuICAgICAgICAvLyBPbmx5IHNldCB1cCBhIG5ldyBNZWRpYVF1ZXJ5TGlzdCBpZiBpdCBpcyBub3QgYWxyZWFkeSBiZWluZyBsaXN0ZW5lZCBmb3IuXG4gICAgICAgIGlmICh0aGlzLl9xdWVyaWVzLmhhcyhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5fcXVlcmllcy5nZXQocXVlcnkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBtcWwgPSB0aGlzLl9tZWRpYU1hdGNoZXIubWF0Y2hNZWRpYShxdWVyeSk7XG4gICAgICAgIC8vIENyZWF0ZSBjYWxsYmFjayBmb3IgbWF0Y2ggY2hhbmdlcyBhbmQgYWRkIGl0IGlzIGFzIGEgbGlzdGVuZXIuXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgcXVlcnlPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG9ic2VydmVyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIC8vIExpc3RlbmVyIGNhbGxiYWNrIG1ldGhvZHMgYXJlIHdyYXBwZWQgdG8gYmUgcGxhY2VkIGJhY2sgaW4gbmdab25lLiBDYWxsYmFja3MgbXVzdCBiZSBwbGFjZWRcbiAgICAgICAgICAgIC8vIGJhY2sgaW50byB0aGUgem9uZSBiZWNhdXNlIG1hdGNoTWVkaWEgaXMgb25seSBpbmNsdWRlZCBpbiBab25lLmpzIGJ5IGxvYWRpbmcgdGhlXG4gICAgICAgICAgICAvLyB3ZWJhcGlzLW1lZGlhLXF1ZXJ5LmpzIGZpbGUgYWxvbmdzaWRlIHRoZSB6b25lLmpzIGZpbGUuICBBZGRpdGlvbmFsbHksIHNvbWUgYnJvd3NlcnMgZG8gbm90XG4gICAgICAgICAgICAvLyBoYXZlIE1lZGlhUXVlcnlMaXN0IGluaGVyaXQgZnJvbSBFdmVudFRhcmdldCwgd2hpY2ggY2F1c2VzIGluY29uc2lzdGVuY2llcyBpbiBob3cgWm9uZS5qc1xuICAgICAgICAgICAgLy8gcGF0Y2hlcyBpdC5cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIChlKSA9PiB0aGlzLl96b25lLnJ1bigoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSkpO1xuICAgICAgICAgICAgbXFsLmFkZExpc3RlbmVyKGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBtcWwucmVtb3ZlTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpLnBpcGUoc3RhcnRXaXRoKG1xbCksIG1hcCgoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV4dE1xbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgKG5leHRNcWwpID0+ICh7IHF1ZXJ5LCBtYXRjaGVzOiBuZXh0TXFsLm1hdGNoZXMgfSkpKSwgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3lTdWJqZWN0KSk7XG4gICAgICAgIC8vIEFkZCB0aGUgTWVkaWFRdWVyeUxpc3QgdG8gdGhlIHNldCBvZiBxdWVyaWVzLlxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHsgb2JzZXJ2YWJsZTogcXVlcnlPYnNlcnZhYmxlLCBtcWwgfTtcbiAgICAgICAgdGhpcy5fcXVlcmllcy5zZXQocXVlcnksIG91dHB1dCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuQnJlYWtwb2ludE9ic2VydmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfSxdIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkJyZWFrcG9pbnRPYnNlcnZlci5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE1lZGlhTWF0Y2hlciB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi8gQnJlYWtwb2ludE9ic2VydmVyLsm1cHJvdiA9IGkwLsm1ybVkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gQnJlYWtwb2ludE9ic2VydmVyX0ZhY3RvcnkoKSB7IHJldHVybiBuZXcgQnJlYWtwb2ludE9ic2VydmVyKGkwLsm1ybVpbmplY3QoaTEuTWVkaWFNYXRjaGVyKSwgaTAuybXJtWluamVjdChpMC5OZ1pvbmUpKTsgfSwgdG9rZW46IEJyZWFrcG9pbnRPYnNlcnZlciwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBhbGwgbWVkaWEgcXVlcmllcyBjdXJyZW50bHkgYmVpbmcgbGlzdGVuZWQgZm9yLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQnJlYWtwb2ludE9ic2VydmVyLnByb3RvdHlwZS5fcXVlcmllcztcbiAgICAvKipcbiAgICAgKiBBIHN1YmplY3QgZm9yIGFsbCBvdGhlciBvYnNlcnZhYmxlcyB0byB0YWtlVW50aWwgYmFzZWQgb24uXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBCcmVha3BvaW50T2JzZXJ2ZXIucHJvdG90eXBlLl9kZXN0cm95U3ViamVjdDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEJyZWFrcG9pbnRPYnNlcnZlci5wcm90b3R5cGUuX21lZGlhTWF0Y2hlcjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEJyZWFrcG9pbnRPYnNlcnZlci5wcm90b3R5cGUuX3pvbmU7XG59XG4vKipcbiAqIFNwbGl0IGVhY2ggcXVlcnkgc3RyaW5nIGludG8gc2VwYXJhdGUgcXVlcnkgc3RyaW5ncyBpZiB0d28gcXVlcmllcyBhcmUgcHJvdmlkZWQgYXMgY29tbWFcbiAqIHNlcGFyYXRlZC5cbiAqIEBwYXJhbSB7P30gcXVlcmllc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXRRdWVyaWVzKHF1ZXJpZXMpIHtcbiAgICByZXR1cm4gcXVlcmllcy5tYXAoKC8qKlxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIChxdWVyeSkgPT4gcXVlcnkuc3BsaXQoJywnKSkpXG4gICAgICAgIC5yZWR1Y2UoKC8qKlxuICAgICAqIEBwYXJhbSB7P30gYTFcbiAgICAgKiBAcGFyYW0gez99IGEyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICAoYTEsIGEyKSA9PiBhMS5jb25jYXQoYTIpKSlcbiAgICAgICAgLm1hcCgoLyoqXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgcXVlcnkgPT4gcXVlcnkudHJpbSgpKSk7XG59XG4iXX0=