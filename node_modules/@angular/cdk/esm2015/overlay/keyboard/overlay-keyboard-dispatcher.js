/**
 * @fileoverview added by tsickle
 * Generated from: src/cdk/overlay/keyboard/overlay-keyboard-dispatcher.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { DOCUMENT } from '@angular/common';
import { Inject, Injectable, Optional, SkipSelf, } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
/**
 * Service for dispatching keyboard events that land on the body to appropriate overlay ref,
 * if any. It maintains a list of attached overlays to determine best suited overlay based
 * on event target and order of overlay opens.
 */
import * as ɵngcc0 from '@angular/core';
export class OverlayKeyboardDispatcher {
    /**
     * @param {?} document
     */
    constructor(document) {
        /**
         * Currently attached overlays in the order they were attached.
         */
        this._attachedOverlays = [];
        /**
         * Keyboard event listener that will be attached to the body.
         */
        this._keydownListener = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /** @type {?} */
            const overlays = this._attachedOverlays;
            for (let i = overlays.length - 1; i > -1; i--) {
                // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.
                // We want to target the most recent overlay, rather than trying to match where the event came
                // from, because some components might open an overlay, but keep focus on a trigger element
                // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,
                // because we don't want overlays that don't handle keyboard events to block the ones below
                // them that do.
                if (overlays[i]._keydownEventSubscriptions > 0) {
                    overlays[i]._keydownEvents.next(event);
                    break;
                }
            }
        });
        this._document = document;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._detach();
    }
    /**
     * Add a new overlay to the list of attached overlay refs.
     * @param {?} overlayRef
     * @return {?}
     */
    add(overlayRef) {
        // Ensure that we don't get the same overlay multiple times.
        this.remove(overlayRef);
        // Lazily start dispatcher once first overlay is added
        if (!this._isAttached) {
            this._document.body.addEventListener('keydown', this._keydownListener);
            this._isAttached = true;
        }
        this._attachedOverlays.push(overlayRef);
    }
    /**
     * Remove an overlay from the list of attached overlay refs.
     * @param {?} overlayRef
     * @return {?}
     */
    remove(overlayRef) {
        /** @type {?} */
        const index = this._attachedOverlays.indexOf(overlayRef);
        if (index > -1) {
            this._attachedOverlays.splice(index, 1);
        }
        // Remove the global listener once there are no more overlays.
        if (this._attachedOverlays.length === 0) {
            this._detach();
        }
    }
    /**
     * Detaches the global keyboard event listener.
     * @private
     * @return {?}
     */
    _detach() {
        if (this._isAttached) {
            this._document.body.removeEventListener('keydown', this._keydownListener);
            this._isAttached = false;
        }
    }
}
OverlayKeyboardDispatcher.ɵfac = function OverlayKeyboardDispatcher_Factory(t) { return new (t || OverlayKeyboardDispatcher)(ɵngcc0.ɵɵinject(DOCUMENT)); };
/** @nocollapse */
OverlayKeyboardDispatcher.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
/** @nocollapse */ OverlayKeyboardDispatcher.ɵprov = i0.ɵɵdefineInjectable({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(i0.ɵɵinject(i1.DOCUMENT)); }, token: OverlayKeyboardDispatcher, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(OverlayKeyboardDispatcher, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, null); })();
if (false) {
    /**
     * Currently attached overlays in the order they were attached.
     * @type {?}
     */
    OverlayKeyboardDispatcher.prototype._attachedOverlays;
    /**
     * @type {?}
     * @private
     */
    OverlayKeyboardDispatcher.prototype._document;
    /**
     * @type {?}
     * @private
     */
    OverlayKeyboardDispatcher.prototype._isAttached;
    /**
     * Keyboard event listener that will be attached to the body.
     * @type {?}
     * @private
     */
    OverlayKeyboardDispatcher.prototype._keydownListener;
}
/**
 * \@docs-private \@deprecated \@breaking-change 8.0.0
 * @param {?} dispatcher
 * @param {?} _document
 * @return {?}
 */
export function OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {
    return dispatcher || new OverlayKeyboardDispatcher(_document);
}
/**
 * \@docs-private \@deprecated \@breaking-change 8.0.0
 * @type {?}
 */
export const OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {
    // If there is already an OverlayKeyboardDispatcher available, use that.
    // Otherwise, provide a new one.
    provide: OverlayKeyboardDispatcher,
    deps: [
        [new Optional(), new SkipSelf(), OverlayKeyboardDispatcher],
        (/** @type {?} */ (
        // Coerce to `InjectionToken` so that the `deps` match the "shape"
        // of the type expected by Angular
        DOCUMENT))
    ],
    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L2ZpbmFsMy9jdXJzb3Mvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Nkay9lc20yMDE1L292ZXJsYXkva2V5Ym9hcmQvb3ZlcmxheS1rZXlib2FyZC1kaXNwYXRjaGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtGQywwSkFHQzs7Ozs7Ozs7Ozs7O2tDQUs4UCIsImZpbGUiOiJvdmVybGF5LWtleWJvYXJkLWRpc3BhdGNoZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogR2VuZXJhdGVkIGZyb206IHNyYy9jZGsvb3ZlcmxheS9rZXlib2FyZC9vdmVybGF5LWtleWJvYXJkLWRpc3BhdGNoZXIudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIE9wdGlvbmFsLCBTa2lwU2VsZiwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIGkwIGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgKiBhcyBpMSBmcm9tIFwiQGFuZ3VsYXIvY29tbW9uXCI7XG4vKipcbiAqIFNlcnZpY2UgZm9yIGRpc3BhdGNoaW5nIGtleWJvYXJkIGV2ZW50cyB0aGF0IGxhbmQgb24gdGhlIGJvZHkgdG8gYXBwcm9wcmlhdGUgb3ZlcmxheSByZWYsXG4gKiBpZiBhbnkuIEl0IG1haW50YWlucyBhIGxpc3Qgb2YgYXR0YWNoZWQgb3ZlcmxheXMgdG8gZGV0ZXJtaW5lIGJlc3Qgc3VpdGVkIG92ZXJsYXkgYmFzZWRcbiAqIG9uIGV2ZW50IHRhcmdldCBhbmQgb3JkZXIgb2Ygb3ZlcmxheSBvcGVucy5cbiAqL1xuZXhwb3J0IGNsYXNzIE92ZXJsYXlLZXlib2FyZERpc3BhdGNoZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudGx5IGF0dGFjaGVkIG92ZXJsYXlzIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgYXR0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hdHRhY2hlZE92ZXJsYXlzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZXlib2FyZCBldmVudCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIGJvZHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9rZXlkb3duTGlzdGVuZXIgPSAoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSB0aGlzLl9hdHRhY2hlZE92ZXJsYXlzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG92ZXJsYXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGtleWRvd24gZXZlbnQgdG8gdGhlIHRvcCBvdmVybGF5IHdoaWNoIGhhcyBzdWJzY3JpYmVycyB0byBpdHMga2V5ZG93biBldmVudHMuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byB0YXJnZXQgdGhlIG1vc3QgcmVjZW50IG92ZXJsYXksIHJhdGhlciB0aGFuIHRyeWluZyB0byBtYXRjaCB3aGVyZSB0aGUgZXZlbnQgY2FtZVxuICAgICAgICAgICAgICAgIC8vIGZyb20sIGJlY2F1c2Ugc29tZSBjb21wb25lbnRzIG1pZ2h0IG9wZW4gYW4gb3ZlcmxheSwgYnV0IGtlZXAgZm9jdXMgb24gYSB0cmlnZ2VyIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBmb3Igc2VsZWN0IGFuZCBhdXRvY29tcGxldGUpLiBXZSBza2lwIG92ZXJsYXlzIHdpdGhvdXQga2V5ZG93biBldmVudCBzdWJzY3JpcHRpb25zLFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBvdmVybGF5cyB0aGF0IGRvbid0IGhhbmRsZSBrZXlib2FyZCBldmVudHMgdG8gYmxvY2sgdGhlIG9uZXMgYmVsb3dcbiAgICAgICAgICAgICAgICAvLyB0aGVtIHRoYXQgZG8uXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXlzW2ldLl9rZXlkb3duRXZlbnRTdWJzY3JpcHRpb25zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5c1tpXS5fa2V5ZG93bkV2ZW50cy5uZXh0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGV0YWNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBvdmVybGF5IHRvIHRoZSBsaXN0IG9mIGF0dGFjaGVkIG92ZXJsYXkgcmVmcy5cbiAgICAgKiBAcGFyYW0gez99IG92ZXJsYXlSZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGFkZChvdmVybGF5UmVmKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGRvbid0IGdldCB0aGUgc2FtZSBvdmVybGF5IG11bHRpcGxlIHRpbWVzLlxuICAgICAgICB0aGlzLnJlbW92ZShvdmVybGF5UmVmKTtcbiAgICAgICAgLy8gTGF6aWx5IHN0YXJ0IGRpc3BhdGNoZXIgb25jZSBmaXJzdCBvdmVybGF5IGlzIGFkZGVkXG4gICAgICAgIGlmICghdGhpcy5faXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dGFjaGVkT3ZlcmxheXMucHVzaChvdmVybGF5UmVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIG92ZXJsYXkgZnJvbSB0aGUgbGlzdCBvZiBhdHRhY2hlZCBvdmVybGF5IHJlZnMuXG4gICAgICogQHBhcmFtIHs/fSBvdmVybGF5UmVmXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICByZW1vdmUob3ZlcmxheVJlZikge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYXR0YWNoZWRPdmVybGF5cy5pbmRleE9mKG92ZXJsYXlSZWYpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRPdmVybGF5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIGxpc3RlbmVyIG9uY2UgdGhlcmUgYXJlIG5vIG1vcmUgb3ZlcmxheXMuXG4gICAgICAgIGlmICh0aGlzLl9hdHRhY2hlZE92ZXJsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgdGhlIGdsb2JhbCBrZXlib2FyZCBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2RldGFjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25MaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLl9pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5PdmVybGF5S2V5Ym9hcmREaXNwYXRjaGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlLCBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfSxdIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk92ZXJsYXlLZXlib2FyZERpc3BhdGNoZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW0RPQ1VNRU5ULF0gfV0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqLyBPdmVybGF5S2V5Ym9hcmREaXNwYXRjaGVyLsm1cHJvdiA9IGkwLsm1ybVkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gT3ZlcmxheUtleWJvYXJkRGlzcGF0Y2hlcl9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IE92ZXJsYXlLZXlib2FyZERpc3BhdGNoZXIoaTAuybXJtWluamVjdChpMS5ET0NVTUVOVCkpOyB9LCB0b2tlbjogT3ZlcmxheUtleWJvYXJkRGlzcGF0Y2hlciwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50bHkgYXR0YWNoZWQgb3ZlcmxheXMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSBhdHRhY2hlZC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBPdmVybGF5S2V5Ym9hcmREaXNwYXRjaGVyLnByb3RvdHlwZS5fYXR0YWNoZWRPdmVybGF5cztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE92ZXJsYXlLZXlib2FyZERpc3BhdGNoZXIucHJvdG90eXBlLl9kb2N1bWVudDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE92ZXJsYXlLZXlib2FyZERpc3BhdGNoZXIucHJvdG90eXBlLl9pc0F0dGFjaGVkO1xuICAgIC8qKlxuICAgICAqIEtleWJvYXJkIGV2ZW50IGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgYm9keS5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE92ZXJsYXlLZXlib2FyZERpc3BhdGNoZXIucHJvdG90eXBlLl9rZXlkb3duTGlzdGVuZXI7XG59XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZSBcXEBkZXByZWNhdGVkIFxcQGJyZWFraW5nLWNoYW5nZSA4LjAuMFxuICogQHBhcmFtIHs/fSBkaXNwYXRjaGVyXG4gKiBAcGFyYW0gez99IF9kb2N1bWVudFxuICogQHJldHVybiB7P31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE9WRVJMQVlfS0VZQk9BUkRfRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZKGRpc3BhdGNoZXIsIF9kb2N1bWVudCkge1xuICAgIHJldHVybiBkaXNwYXRjaGVyIHx8IG5ldyBPdmVybGF5S2V5Ym9hcmREaXNwYXRjaGVyKF9kb2N1bWVudCk7XG59XG4vKipcbiAqIFxcQGRvY3MtcHJpdmF0ZSBcXEBkZXByZWNhdGVkIFxcQGJyZWFraW5nLWNoYW5nZSA4LjAuMFxuICogQHR5cGUgez99XG4gKi9cbmV4cG9ydCBjb25zdCBPVkVSTEFZX0tFWUJPQVJEX0RJU1BBVENIRVJfUFJPVklERVIgPSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBPdmVybGF5S2V5Ym9hcmREaXNwYXRjaGVyIGF2YWlsYWJsZSwgdXNlIHRoYXQuXG4gICAgLy8gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBPdmVybGF5S2V5Ym9hcmREaXNwYXRjaGVyLFxuICAgIGRlcHM6IFtcbiAgICAgICAgW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgT3ZlcmxheUtleWJvYXJkRGlzcGF0Y2hlcl0sXG4gICAgICAgICgvKiogQHR5cGUgez99ICovIChcbiAgICAgICAgLy8gQ29lcmNlIHRvIGBJbmplY3Rpb25Ub2tlbmAgc28gdGhhdCB0aGUgYGRlcHNgIG1hdGNoIHRoZSBcInNoYXBlXCJcbiAgICAgICAgLy8gb2YgdGhlIHR5cGUgZXhwZWN0ZWQgYnkgQW5ndWxhclxuICAgICAgICBET0NVTUVOVCkpXG4gICAgXSxcbiAgICB1c2VGYWN0b3J5OiBPVkVSTEFZX0tFWUJPQVJEX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWVxufTtcbiJdfQ==