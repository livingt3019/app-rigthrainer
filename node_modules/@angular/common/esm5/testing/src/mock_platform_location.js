/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __assign, __decorate, __metadata, __param } from "tslib";
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { Subject } from 'rxjs';
/**
 * Parser from https://tools.ietf.org/html/rfc3986#appendix-B
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 *
 * Example: http://www.ics.uci.edu/pub/ietf/uri/#Related
 *
 * Results in:
 *
 * $1 = http:
 * $2 = http
 * $3 = //www.ics.uci.edu
 * $4 = www.ics.uci.edu
 * $5 = /pub/ietf/uri/
 * $6 = <undefined>
 * $7 = <undefined>
 * $8 = #Related
 * $9 = Related
 */
import * as ɵngcc0 from '@angular/core';
var urlParse = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
function parseUrl(urlStr, baseHref) {
    var verifyProtocol = /^((http[s]?|ftp):\/\/)/;
    var serverBase;
    // URL class requires full URL. If the URL string doesn't start with protocol, we need to add
    // an arbitrary base URL which can be removed afterward.
    if (!verifyProtocol.test(urlStr)) {
        serverBase = 'http://empty.com/';
    }
    var parsedUrl;
    try {
        parsedUrl = new URL(urlStr, serverBase);
    }
    catch (e) {
        var result = urlParse.exec(serverBase || '' + urlStr);
        if (!result) {
            throw new Error("Invalid URL: " + urlStr + " with base: " + baseHref);
        }
        var hostSplit = result[4].split(':');
        parsedUrl = {
            protocol: result[1],
            hostname: hostSplit[0],
            port: hostSplit[1] || '',
            pathname: result[5],
            search: result[6],
            hash: result[8],
        };
    }
    if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {
        parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);
    }
    return {
        hostname: !serverBase && parsedUrl.hostname || '',
        protocol: !serverBase && parsedUrl.protocol || '',
        port: !serverBase && parsedUrl.port || '',
        pathname: parsedUrl.pathname || '/',
        search: parsedUrl.search || '',
        hash: parsedUrl.hash || '',
    };
}
/**
 * Provider for mock platform location config
 *
 * @publicApi
 */
export var MOCK_PLATFORM_LOCATION_CONFIG = new InjectionToken('MOCK_PLATFORM_LOCATION_CONFIG');
/**
 * Mock implementation of URL state.
 *
 * @publicApi
 */
var MockPlatformLocation = /** @class */ (function () {
    function MockPlatformLocation(config) {
        this.baseHref = '';
        this.hashUpdate = new Subject();
        this.urlChanges = [{ hostname: '', protocol: '', port: '', pathname: '/', search: '', hash: '', state: null }];
        if (config) {
            this.baseHref = config.appBaseHref || '';
            var parsedChanges = this.parseChanges(null, config.startUrl || 'http://<empty>/', this.baseHref);
            this.urlChanges[0] = __assign({}, parsedChanges);
        }
    }
    Object.defineProperty(MockPlatformLocation.prototype, "hostname", {
        get: function () { return this.urlChanges[0].hostname; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "protocol", {
        get: function () { return this.urlChanges[0].protocol; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "port", {
        get: function () { return this.urlChanges[0].port; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "pathname", {
        get: function () { return this.urlChanges[0].pathname; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "search", {
        get: function () { return this.urlChanges[0].search; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "hash", {
        get: function () { return this.urlChanges[0].hash; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "state", {
        get: function () { return this.urlChanges[0].state; },
        enumerable: true,
        configurable: true
    });
    MockPlatformLocation.prototype.getBaseHrefFromDOM = function () { return this.baseHref; };
    MockPlatformLocation.prototype.onPopState = function (fn) {
        // No-op: a state stack is not implemented, so
        // no events will ever come.
    };
    MockPlatformLocation.prototype.onHashChange = function (fn) { this.hashUpdate.subscribe(fn); };
    Object.defineProperty(MockPlatformLocation.prototype, "href", {
        get: function () {
            var url = this.protocol + "//" + this.hostname + (this.port ? ':' + this.port : '');
            url += "" + (this.pathname === '/' ? '' : this.pathname) + this.search + this.hash;
            return url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockPlatformLocation.prototype, "url", {
        get: function () { return "" + this.pathname + this.search + this.hash; },
        enumerable: true,
        configurable: true
    });
    MockPlatformLocation.prototype.parseChanges = function (state, url, baseHref) {
        if (baseHref === void 0) { baseHref = ''; }
        // When the `history.state` value is stored, it is always copied.
        state = JSON.parse(JSON.stringify(state));
        return __assign(__assign({}, parseUrl(url, baseHref)), { state: state });
    };
    MockPlatformLocation.prototype.replaceState = function (state, title, newUrl) {
        var _a = this.parseChanges(state, newUrl), pathname = _a.pathname, search = _a.search, parsedState = _a.state, hash = _a.hash;
        this.urlChanges[0] = __assign(__assign({}, this.urlChanges[0]), { pathname: pathname, search: search, hash: hash, state: parsedState });
    };
    MockPlatformLocation.prototype.pushState = function (state, title, newUrl) {
        var _a = this.parseChanges(state, newUrl), pathname = _a.pathname, search = _a.search, parsedState = _a.state, hash = _a.hash;
        this.urlChanges.unshift(__assign(__assign({}, this.urlChanges[0]), { pathname: pathname, search: search, hash: hash, state: parsedState }));
    };
    MockPlatformLocation.prototype.forward = function () { throw new Error('Not implemented'); };
    MockPlatformLocation.prototype.back = function () {
        var _this = this;
        var oldUrl = this.url;
        var oldHash = this.hash;
        this.urlChanges.shift();
        var newHash = this.hash;
        if (oldHash !== newHash) {
            scheduleMicroTask(function () { return _this.hashUpdate.next({
                type: 'hashchange', state: null, oldUrl: oldUrl, newUrl: _this.url
            }); });
        }
    };
    MockPlatformLocation.prototype.getState = function () { return this.state; };
    MockPlatformLocation = __decorate([ __param(0, Inject(MOCK_PLATFORM_LOCATION_CONFIG)), __param(0, Optional()),
        __metadata("design:paramtypes", [Object])
    ], MockPlatformLocation);
MockPlatformLocation.ɵfac = function MockPlatformLocation_Factory(t) { return new (t || MockPlatformLocation)(ɵngcc0.ɵɵinject(MOCK_PLATFORM_LOCATION_CONFIG, 8)); };
MockPlatformLocation.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MockPlatformLocation, factory: function (t) { return MockPlatformLocation.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MockPlatformLocation, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [MOCK_PLATFORM_LOCATION_CONFIG]
            }, {
                type: Optional
            }] }]; }, null); })();
    return MockPlatformLocation;
}());
export { MockPlatformLocation };
export function scheduleMicroTask(cb) {
    Promise.resolve(null).then(cb);
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImQ6L2ZpbmFsMy9jdXJzb3Mvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9lc201L3Rlc3Rpbmcvc3JjL21vY2tfcGxhdGZvcm1fbG9jYXRpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FpSnVDLEFBRWhDOzs7Ozs7Ozs7Ozs7a0NBRXNCIiwiZmlsZSI6Im1vY2tfcGxhdGZvcm1fbG9jYXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBfX2Fzc2lnbiwgX19kZWNvcmF0ZSwgX19tZXRhZGF0YSwgX19wYXJhbSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbi8qKlxuICogUGFyc2VyIGZyb20gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQlxuICogXigoW146Lz8jXSspOik/KC8vKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpP1xuICogIDEyICAgICAgICAgICAgMyAgNCAgICAgICAgICA1ICAgICAgIDYgIDcgICAgICAgIDggOVxuICpcbiAqIEV4YW1wbGU6IGh0dHA6Ly93d3cuaWNzLnVjaS5lZHUvcHViL2lldGYvdXJpLyNSZWxhdGVkXG4gKlxuICogUmVzdWx0cyBpbjpcbiAqXG4gKiAkMSA9IGh0dHA6XG4gKiAkMiA9IGh0dHBcbiAqICQzID0gLy93d3cuaWNzLnVjaS5lZHVcbiAqICQ0ID0gd3d3Lmljcy51Y2kuZWR1XG4gKiAkNSA9IC9wdWIvaWV0Zi91cmkvXG4gKiAkNiA9IDx1bmRlZmluZWQ+XG4gKiAkNyA9IDx1bmRlZmluZWQ+XG4gKiAkOCA9ICNSZWxhdGVkXG4gKiAkOSA9IFJlbGF0ZWRcbiAqL1xudmFyIHVybFBhcnNlID0gL14oKFteOlxcLz8jXSspOik/KFxcL1xcLyhbXlxcLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPy87XG5mdW5jdGlvbiBwYXJzZVVybCh1cmxTdHIsIGJhc2VIcmVmKSB7XG4gICAgdmFyIHZlcmlmeVByb3RvY29sID0gL14oKGh0dHBbc10/fGZ0cCk6XFwvXFwvKS87XG4gICAgdmFyIHNlcnZlckJhc2U7XG4gICAgLy8gVVJMIGNsYXNzIHJlcXVpcmVzIGZ1bGwgVVJMLiBJZiB0aGUgVVJMIHN0cmluZyBkb2Vzbid0IHN0YXJ0IHdpdGggcHJvdG9jb2wsIHdlIG5lZWQgdG8gYWRkXG4gICAgLy8gYW4gYXJiaXRyYXJ5IGJhc2UgVVJMIHdoaWNoIGNhbiBiZSByZW1vdmVkIGFmdGVyd2FyZC5cbiAgICBpZiAoIXZlcmlmeVByb3RvY29sLnRlc3QodXJsU3RyKSkge1xuICAgICAgICBzZXJ2ZXJCYXNlID0gJ2h0dHA6Ly9lbXB0eS5jb20vJztcbiAgICB9XG4gICAgdmFyIHBhcnNlZFVybDtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybFN0ciwgc2VydmVyQmFzZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB1cmxQYXJzZS5leGVjKHNlcnZlckJhc2UgfHwgJycgKyB1cmxTdHIpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBVUkw6IFwiICsgdXJsU3RyICsgXCIgd2l0aCBiYXNlOiBcIiArIGJhc2VIcmVmKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9zdFNwbGl0ID0gcmVzdWx0WzRdLnNwbGl0KCc6Jyk7XG4gICAgICAgIHBhcnNlZFVybCA9IHtcbiAgICAgICAgICAgIHByb3RvY29sOiByZXN1bHRbMV0sXG4gICAgICAgICAgICBob3N0bmFtZTogaG9zdFNwbGl0WzBdLFxuICAgICAgICAgICAgcG9ydDogaG9zdFNwbGl0WzFdIHx8ICcnLFxuICAgICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdFs1XSxcbiAgICAgICAgICAgIHNlYXJjaDogcmVzdWx0WzZdLFxuICAgICAgICAgICAgaGFzaDogcmVzdWx0WzhdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocGFyc2VkVXJsLnBhdGhuYW1lICYmIHBhcnNlZFVybC5wYXRobmFtZS5pbmRleE9mKGJhc2VIcmVmKSA9PT0gMCkge1xuICAgICAgICBwYXJzZWRVcmwucGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWUuc3Vic3RyaW5nKGJhc2VIcmVmLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhvc3RuYW1lOiAhc2VydmVyQmFzZSAmJiBwYXJzZWRVcmwuaG9zdG5hbWUgfHwgJycsXG4gICAgICAgIHByb3RvY29sOiAhc2VydmVyQmFzZSAmJiBwYXJzZWRVcmwucHJvdG9jb2wgfHwgJycsXG4gICAgICAgIHBvcnQ6ICFzZXJ2ZXJCYXNlICYmIHBhcnNlZFVybC5wb3J0IHx8ICcnLFxuICAgICAgICBwYXRobmFtZTogcGFyc2VkVXJsLnBhdGhuYW1lIHx8ICcvJyxcbiAgICAgICAgc2VhcmNoOiBwYXJzZWRVcmwuc2VhcmNoIHx8ICcnLFxuICAgICAgICBoYXNoOiBwYXJzZWRVcmwuaGFzaCB8fCAnJyxcbiAgICB9O1xufVxuLyoqXG4gKiBQcm92aWRlciBmb3IgbW9jayBwbGF0Zm9ybSBsb2NhdGlvbiBjb25maWdcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmV4cG9ydCB2YXIgTU9DS19QTEFURk9STV9MT0NBVElPTl9DT05GSUcgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ01PQ0tfUExBVEZPUk1fTE9DQVRJT05fQ09ORklHJyk7XG4vKipcbiAqIE1vY2sgaW1wbGVtZW50YXRpb24gb2YgVVJMIHN0YXRlLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIE1vY2tQbGF0Zm9ybUxvY2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vY2tQbGF0Zm9ybUxvY2F0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLmJhc2VIcmVmID0gJyc7XG4gICAgICAgIHRoaXMuaGFzaFVwZGF0ZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMudXJsQ2hhbmdlcyA9IFt7IGhvc3RuYW1lOiAnJywgcHJvdG9jb2w6ICcnLCBwb3J0OiAnJywgcGF0aG5hbWU6ICcvJywgc2VhcmNoOiAnJywgaGFzaDogJycsIHN0YXRlOiBudWxsIH1dO1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VIcmVmID0gY29uZmlnLmFwcEJhc2VIcmVmIHx8ICcnO1xuICAgICAgICAgICAgdmFyIHBhcnNlZENoYW5nZXMgPSB0aGlzLnBhcnNlQ2hhbmdlcyhudWxsLCBjb25maWcuc3RhcnRVcmwgfHwgJ2h0dHA6Ly88ZW1wdHk+LycsIHRoaXMuYmFzZUhyZWYpO1xuICAgICAgICAgICAgdGhpcy51cmxDaGFuZ2VzWzBdID0gX19hc3NpZ24oe30sIHBhcnNlZENoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2NrUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwiaG9zdG5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXJsQ2hhbmdlc1swXS5ob3N0bmFtZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJwcm90b2NvbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy51cmxDaGFuZ2VzWzBdLnByb3RvY29sOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInBvcnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXJsQ2hhbmdlc1swXS5wb3J0OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInBhdGhuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVybENoYW5nZXNbMF0ucGF0aG5hbWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2NrUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwic2VhcmNoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVybENoYW5nZXNbMF0uc2VhcmNoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImhhc2hcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXJsQ2hhbmdlc1swXS5oYXNoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInN0YXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVybENoYW5nZXNbMF0uc3RhdGU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5nZXRCYXNlSHJlZkZyb21ET00gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmJhc2VIcmVmOyB9O1xuICAgIE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIC8vIE5vLW9wOiBhIHN0YXRlIHN0YWNrIGlzIG5vdCBpbXBsZW1lbnRlZCwgc29cbiAgICAgICAgLy8gbm8gZXZlbnRzIHdpbGwgZXZlciBjb21lLlxuICAgIH07XG4gICAgTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLm9uSGFzaENoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLmhhc2hVcGRhdGUuc3Vic2NyaWJlKGZuKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImhyZWZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLnByb3RvY29sICsgXCIvL1wiICsgdGhpcy5ob3N0bmFtZSArICh0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJyk7XG4gICAgICAgICAgICB1cmwgKz0gXCJcIiArICh0aGlzLnBhdGhuYW1lID09PSAnLycgPyAnJyA6IHRoaXMucGF0aG5hbWUpICsgdGhpcy5zZWFyY2ggKyB0aGlzLmhhc2g7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJcIiArIHRoaXMucGF0aG5hbWUgKyB0aGlzLnNlYXJjaCArIHRoaXMuaGFzaDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnBhcnNlQ2hhbmdlcyA9IGZ1bmN0aW9uIChzdGF0ZSwgdXJsLCBiYXNlSHJlZikge1xuICAgICAgICBpZiAoYmFzZUhyZWYgPT09IHZvaWQgMCkgeyBiYXNlSHJlZiA9ICcnOyB9XG4gICAgICAgIC8vIFdoZW4gdGhlIGBoaXN0b3J5LnN0YXRlYCB2YWx1ZSBpcyBzdG9yZWQsIGl0IGlzIGFsd2F5cyBjb3BpZWQuXG4gICAgICAgIHN0YXRlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcnNlVXJsKHVybCwgYmFzZUhyZWYpKSwgeyBzdGF0ZTogc3RhdGUgfSk7XG4gICAgfTtcbiAgICBNb2NrUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgbmV3VXJsKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucGFyc2VDaGFuZ2VzKHN0YXRlLCBuZXdVcmwpLCBwYXRobmFtZSA9IF9hLnBhdGhuYW1lLCBzZWFyY2ggPSBfYS5zZWFyY2gsIHBhcnNlZFN0YXRlID0gX2Euc3RhdGUsIGhhc2ggPSBfYS5oYXNoO1xuICAgICAgICB0aGlzLnVybENoYW5nZXNbMF0gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy51cmxDaGFuZ2VzWzBdKSwgeyBwYXRobmFtZTogcGF0aG5hbWUsIHNlYXJjaDogc2VhcmNoLCBoYXNoOiBoYXNoLCBzdGF0ZTogcGFyc2VkU3RhdGUgfSk7XG4gICAgfTtcbiAgICBNb2NrUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUucHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgbmV3VXJsKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucGFyc2VDaGFuZ2VzKHN0YXRlLCBuZXdVcmwpLCBwYXRobmFtZSA9IF9hLnBhdGhuYW1lLCBzZWFyY2ggPSBfYS5zZWFyY2gsIHBhcnNlZFN0YXRlID0gX2Euc3RhdGUsIGhhc2ggPSBfYS5oYXNoO1xuICAgICAgICB0aGlzLnVybENoYW5nZXMudW5zaGlmdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy51cmxDaGFuZ2VzWzBdKSwgeyBwYXRobmFtZTogcGF0aG5hbWUsIHNlYXJjaDogc2VhcmNoLCBoYXNoOiBoYXNoLCBzdGF0ZTogcGFyc2VkU3RhdGUgfSkpO1xuICAgIH07XG4gICAgTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgTW9ja1BsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvbGRVcmwgPSB0aGlzLnVybDtcbiAgICAgICAgdmFyIG9sZEhhc2ggPSB0aGlzLmhhc2g7XG4gICAgICAgIHRoaXMudXJsQ2hhbmdlcy5zaGlmdCgpO1xuICAgICAgICB2YXIgbmV3SGFzaCA9IHRoaXMuaGFzaDtcbiAgICAgICAgaWYgKG9sZEhhc2ggIT09IG5ld0hhc2gpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmhhc2hVcGRhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hhc2hjaGFuZ2UnLCBzdGF0ZTogbnVsbCwgb2xkVXJsOiBvbGRVcmwsIG5ld1VybDogX3RoaXMudXJsXG4gICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vY2tQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc3RhdGU7IH07XG4gICAgTW9ja1BsYXRmb3JtTG9jYXRpb24gPSBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX3BhcmFtKDAsIEluamVjdChNT0NLX1BMQVRGT1JNX0xPQ0FUSU9OX0NPTkZJRykpLCBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG4gICAgXSwgTW9ja1BsYXRmb3JtTG9jYXRpb24pO1xuICAgIHJldHVybiBNb2NrUGxhdGZvcm1Mb2NhdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBNb2NrUGxhdGZvcm1Mb2NhdGlvbiB9O1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGNiKSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oY2IpO1xufVxuIl19